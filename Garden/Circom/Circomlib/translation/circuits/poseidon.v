(* Generated by Garden *)
Require Import Garden.Garden.

(* Template signals *)
Module SigmaSignals.
  Record t : Set := {
    (* Input *)
    in_ : F.t;
    (* Output *)
    out : F.t;
    (* Intermediate *)
    in2 : F.t;
    (* Intermediate *)
    in4 : F.t;
  }.

  Module IsNamed.
    Inductive P : forall (A : Set), (t -> A) -> string -> Prop :=
    | in_ : P _ in_ "in"
    | out : P _ out "out"
    | in2 : P _ in2 "in2"
    | in4 : P _ in4 "in4".
  End IsNamed.
End SigmaSignals.

(* Template body *)
Definition Sigma : M.t (BlockUnit.t Empty_set) :=
  M.template_body [] (
    (* Signal Input *)
    do~ M.declare_signal "in" in
    (* Signal Output *)
    do~ M.declare_signal "out" in
    (* Signal Intermediate *)
    do~ M.declare_signal "in2" in
    (* Signal Intermediate *)
    do~ M.declare_signal "in4" in
    do~ M.substitute_var "in2" [] [[ InfixOp.mul ~(| M.var (| "in" |), M.var (| "in" |) |) ]] in
    do~ M.substitute_var "in4" [] [[ InfixOp.mul ~(| M.var (| "in2" |), M.var (| "in2" |) |) ]] in
    do~ M.substitute_var "out" [] [[ InfixOp.mul ~(| M.var (| "in4" |), M.var (| "in" |) |) ]] in
    M.pure BlockUnit.Tt
  ).

(* Template not under-constrained *)
Definition Sigma_not_under_constrained in_ : Prop :=
  exists! out,
  exists in2 in4,
  let signals := SigmaSignals.Build_t in_ out in2 in4 in
  True (* NotUnderConstrained Sigma signals *).

(* Template signals *)
Module ArkSignals.
  Record t : Set := {
    (* Input *)
    in_ : list F.t;
    (* Output *)
    out : list F.t;
  }.

  Module IsNamed.
    Inductive P : forall (A : Set), (t -> A) -> string -> Prop :=
    | in_ : P _ in_ "in"
    | out : P _ out "out".
  End IsNamed.
End ArkSignals.

(* Template body *)
Definition Ark (t C r : F.t) : M.t (BlockUnit.t Empty_set) :=
  M.template_body [("t", t); ("C", C); ("r", r)] (
    (* Signal Input *)
    do~ M.declare_signal "in" in
    (* Signal Output *)
    do~ M.declare_signal "out" in
    (* Var *)
    do~ M.declare_var "i" [[ ([] : list F.t) ]] in
    do~ M.substitute_var "i" [] [[ 0 ]] in
    do~ M.while [[ InfixOp.lesser ~(| M.var (| "i" |), M.var (| "t" |) |) ]] (
      do~ M.substitute_var "out" [Access.Array (M.var (| "i" |))] [[ InfixOp.add ~(| M.var_access (| "in", [Access.Array (M.var (| "i" |))] |), M.var_access (| "C", [Access.Array (InfixOp.add ~(| M.var (| "i" |), M.var (| "r" |) |))] |) |) ]] in
      do~ M.substitute_var "i" [] [[ InfixOp.add ~(| M.var (| "i" |), 1 |) ]] in
      M.pure BlockUnit.Tt
    ) in
    M.pure BlockUnit.Tt
  ).

(* Template not under-constrained *)
Definition Ark_not_under_constrained (t C r : F.t) in_ : Prop :=
  exists! out,
  let signals := ArkSignals.Build_t in_ out in
  True (* NotUnderConstrained Ark t C r signals *).

(* Template signals *)
Module MixSignals.
  Record t : Set := {
    (* Input *)
    in_ : list F.t;
    (* Output *)
    out : list F.t;
  }.

  Module IsNamed.
    Inductive P : forall (A : Set), (t -> A) -> string -> Prop :=
    | in_ : P _ in_ "in"
    | out : P _ out "out".
  End IsNamed.
End MixSignals.

(* Template body *)
Definition Mix (t M : F.t) : M.t (BlockUnit.t Empty_set) :=
  M.template_body [("t", t); ("M", M)] (
    (* Signal Input *)
    do~ M.declare_signal "in" in
    (* Signal Output *)
    do~ M.declare_signal "out" in
    (* Var *)
    do~ M.declare_var "lc" [[ ([] : list F.t) ]] in
    do~ M.substitute_var "lc" [] [[ 0 ]] in
    (* Var *)
    do~ M.declare_var "i" [[ ([] : list F.t) ]] in
    do~ M.substitute_var "i" [] [[ 0 ]] in
    do~ M.while [[ InfixOp.lesser ~(| M.var (| "i" |), M.var (| "t" |) |) ]] (
      do~ M.substitute_var "lc" [] [[ 0 ]] in
      (* Var *)
      do~ M.declare_var "j" [[ ([] : list F.t) ]] in
      do~ M.substitute_var "j" [] [[ 0 ]] in
      do~ M.while [[ InfixOp.lesser ~(| M.var (| "j" |), M.var (| "t" |) |) ]] (
        do~ M.substitute_var "lc" [] [[ InfixOp.add ~(| M.var (| "lc" |), InfixOp.mul ~(| M.var_access (| "M", [Access.Array (M.var (| "j" |)); Access.Array (M.var (| "i" |))] |), M.var_access (| "in", [Access.Array (M.var (| "j" |))] |) |) |) ]] in
        do~ M.substitute_var "j" [] [[ InfixOp.add ~(| M.var (| "j" |), 1 |) ]] in
        M.pure BlockUnit.Tt
      ) in
      do~ M.substitute_var "out" [Access.Array (M.var (| "i" |))] [[ M.var (| "lc" |) ]] in
      do~ M.substitute_var "i" [] [[ InfixOp.add ~(| M.var (| "i" |), 1 |) ]] in
      M.pure BlockUnit.Tt
    ) in
    M.pure BlockUnit.Tt
  ).

(* Template not under-constrained *)
Definition Mix_not_under_constrained (t M : F.t) in_ : Prop :=
  exists! out,
  let signals := MixSignals.Build_t in_ out in
  True (* NotUnderConstrained Mix t M signals *).

(* Template signals *)
Module MixLastSignals.
  Record t : Set := {
    (* Input *)
    in_ : list F.t;
    (* Output *)
    out : F.t;
  }.

  Module IsNamed.
    Inductive P : forall (A : Set), (t -> A) -> string -> Prop :=
    | in_ : P _ in_ "in"
    | out : P _ out "out".
  End IsNamed.
End MixLastSignals.

(* Template body *)
Definition MixLast (t M s : F.t) : M.t (BlockUnit.t Empty_set) :=
  M.template_body [("t", t); ("M", M); ("s", s)] (
    (* Signal Input *)
    do~ M.declare_signal "in" in
    (* Signal Output *)
    do~ M.declare_signal "out" in
    (* Var *)
    do~ M.declare_var "lc" [[ ([] : list F.t) ]] in
    do~ M.substitute_var "lc" [] [[ 0 ]] in
    (* Var *)
    do~ M.declare_var "j" [[ ([] : list F.t) ]] in
    do~ M.substitute_var "j" [] [[ 0 ]] in
    do~ M.while [[ InfixOp.lesser ~(| M.var (| "j" |), M.var (| "t" |) |) ]] (
      do~ M.substitute_var "lc" [] [[ InfixOp.add ~(| M.var (| "lc" |), InfixOp.mul ~(| M.var_access (| "M", [Access.Array (M.var (| "j" |)); Access.Array (M.var (| "s" |))] |), M.var_access (| "in", [Access.Array (M.var (| "j" |))] |) |) |) ]] in
      do~ M.substitute_var "j" [] [[ InfixOp.add ~(| M.var (| "j" |), 1 |) ]] in
      M.pure BlockUnit.Tt
    ) in
    do~ M.substitute_var "out" [] [[ M.var (| "lc" |) ]] in
    M.pure BlockUnit.Tt
  ).

(* Template not under-constrained *)
Definition MixLast_not_under_constrained (t M s : F.t) in_ : Prop :=
  exists! out,
  let signals := MixLastSignals.Build_t in_ out in
  True (* NotUnderConstrained MixLast t M s signals *).

(* Template signals *)
Module MixSSignals.
  Record t : Set := {
    (* Input *)
    in_ : list F.t;
    (* Output *)
    out : list F.t;
  }.

  Module IsNamed.
    Inductive P : forall (A : Set), (t -> A) -> string -> Prop :=
    | in_ : P _ in_ "in"
    | out : P _ out "out".
  End IsNamed.
End MixSSignals.

(* Template body *)
Definition MixS (t S r : F.t) : M.t (BlockUnit.t Empty_set) :=
  M.template_body [("t", t); ("S", S); ("r", r)] (
    (* Signal Input *)
    do~ M.declare_signal "in" in
    (* Signal Output *)
    do~ M.declare_signal "out" in
    (* Var *)
    do~ M.declare_var "lc" [[ ([] : list F.t) ]] in
    do~ M.substitute_var "lc" [] [[ 0 ]] in
    (* Var *)
    do~ M.declare_var "i" [[ ([] : list F.t) ]] in
    do~ M.substitute_var "i" [] [[ 0 ]] in
    do~ M.while [[ InfixOp.lesser ~(| M.var (| "i" |), M.var (| "t" |) |) ]] (
      do~ M.substitute_var "lc" [] [[ InfixOp.add ~(| M.var (| "lc" |), InfixOp.mul ~(| M.var_access (| "S", [Access.Array (InfixOp.add ~(| InfixOp.mul ~(| InfixOp.sub ~(| InfixOp.mul ~(| M.var (| "t" |), 2 |), 1 |), M.var (| "r" |) |), M.var (| "i" |) |))] |), M.var_access (| "in", [Access.Array (M.var (| "i" |))] |) |) |) ]] in
      do~ M.substitute_var "i" [] [[ InfixOp.add ~(| M.var (| "i" |), 1 |) ]] in
      M.pure BlockUnit.Tt
    ) in
    do~ M.substitute_var "out" [Access.Array (0)] [[ M.var (| "lc" |) ]] in
    (* Var *)
    do~ M.declare_var "i" [[ ([] : list F.t) ]] in
    do~ M.substitute_var "i" [] [[ 1 ]] in
    do~ M.while [[ InfixOp.lesser ~(| M.var (| "i" |), M.var (| "t" |) |) ]] (
      do~ M.substitute_var "out" [Access.Array (M.var (| "i" |))] [[ InfixOp.add ~(| M.var_access (| "in", [Access.Array (M.var (| "i" |))] |), InfixOp.mul ~(| M.var_access (| "in", [Access.Array (0)] |), M.var_access (| "S", [Access.Array (InfixOp.sub ~(| InfixOp.add ~(| InfixOp.add ~(| InfixOp.mul ~(| InfixOp.sub ~(| InfixOp.mul ~(| M.var (| "t" |), 2 |), 1 |), M.var (| "r" |) |), M.var (| "t" |) |), M.var (| "i" |) |), 1 |))] |) |) |) ]] in
      do~ M.substitute_var "i" [] [[ InfixOp.add ~(| M.var (| "i" |), 1 |) ]] in
      M.pure BlockUnit.Tt
    ) in
    M.pure BlockUnit.Tt
  ).

(* Template not under-constrained *)
Definition MixS_not_under_constrained (t S r : F.t) in_ : Prop :=
  exists! out,
  let signals := MixSSignals.Build_t in_ out in
  True (* NotUnderConstrained MixS t S r signals *).

(* Template signals *)
Module PoseidonExSignals.
  Record t : Set := {
    (* Input *)
    inputs : list F.t;
    (* Input *)
    initialState : F.t;
    (* Output *)
    out : list F.t;
  }.

  Module IsNamed.
    Inductive P : forall (A : Set), (t -> A) -> string -> Prop :=
    | inputs : P _ inputs "inputs"
    | initialState : P _ initialState "initialState"
    | out : P _ out "out".
  End IsNamed.
End PoseidonExSignals.

(* Template body *)
Definition PoseidonEx (nInputs nOuts : F.t) : M.t (BlockUnit.t Empty_set) :=
  M.template_body [("nInputs", nInputs); ("nOuts", nOuts)] (
    (* Signal Input *)
    do~ M.declare_signal "inputs" in
    (* Signal Input *)
    do~ M.declare_signal "initialState" in
    (* Signal Output *)
    do~ M.declare_signal "out" in
    (* Var *)
    do~ M.declare_var "N_ROUNDS_P" [[ [ 16 ] ]] in
    do~ M.substitute_var "N_ROUNDS_P" [] [[ array_with_repeat (0) (16) ]] in
    do~ M.substitute_var "N_ROUNDS_P" [] [[ [ 56; 57; 56; 60; 60; 63; 64; 63; 60; 66; 60; 65; 70; 60; 64; 68 ] ]] in
    (* Var *)
    do~ M.declare_var "t" [[ ([] : list F.t) ]] in
    do~ M.substitute_var "t" [] [[ InfixOp.add ~(| M.var (| "nInputs" |), 1 |) ]] in
    (* Var *)
    do~ M.declare_var "nRoundsF" [[ ([] : list F.t) ]] in
    do~ M.substitute_var "nRoundsF" [] [[ 8 ]] in
    (* Var *)
    do~ M.declare_var "nRoundsP" [[ ([] : list F.t) ]] in
    do~ M.substitute_var "nRoundsP" [] [[ M.var_access (| "N_ROUNDS_P", [Access.Array (InfixOp.sub ~(| M.var (| "t" |), 2 |))] |) ]] in
    (* Var *)
    do~ M.declare_var "C" [[ [ InfixOp.add ~(| InfixOp.mul ~(| M.var (| "t" |), M.var (| "nRoundsF" |) |), M.var (| "nRoundsP" |) |) ] ]] in
    do~ M.substitute_var "C" [] [[ array_with_repeat (0) (InfixOp.add ~(| InfixOp.mul ~(| M.var (| "t" |), M.var (| "nRoundsF" |) |), M.var (| "nRoundsP" |) |)) ]] in
    do~ M.substitute_var "C" [] [[ M.call_function ~(| "POSEIDON_C", [ M.var (| "t" |) ] |) ]] in
    (* Var *)
    do~ M.declare_var "S" [[ [ InfixOp.mul ~(| M.var_access (| "N_ROUNDS_P", [Access.Array (InfixOp.sub ~(| M.var (| "t" |), 2 |))] |), InfixOp.sub ~(| InfixOp.mul ~(| M.var (| "t" |), 2 |), 1 |) |) ] ]] in
    do~ M.substitute_var "S" [] [[ array_with_repeat (0) (InfixOp.mul ~(| M.var_access (| "N_ROUNDS_P", [Access.Array (InfixOp.sub ~(| M.var (| "t" |), 2 |))] |), InfixOp.sub ~(| InfixOp.mul ~(| M.var (| "t" |), 2 |), 1 |) |)) ]] in
    do~ M.substitute_var "S" [] [[ M.call_function ~(| "POSEIDON_S", [ M.var (| "t" |) ] |) ]] in
    (* Var *)
    do~ M.declare_var "M" [[ [ M.var (| "t" |); M.var (| "t" |) ] ]] in
    do~ M.substitute_var "M" [] [[ array_with_repeat (array_with_repeat (0) (M.var (| "t" |))) (M.var (| "t" |)) ]] in
    do~ M.substitute_var "M" [] [[ M.call_function ~(| "POSEIDON_M", [ M.var (| "t" |) ] |) ]] in
    (* Var *)
    do~ M.declare_var "P" [[ [ M.var (| "t" |); M.var (| "t" |) ] ]] in
    do~ M.substitute_var "P" [] [[ array_with_repeat (array_with_repeat (0) (M.var (| "t" |))) (M.var (| "t" |)) ]] in
    do~ M.substitute_var "P" [] [[ M.call_function ~(| "POSEIDON_P", [ M.var (| "t" |) ] |) ]] in
    (* Component *)
    do~ M.declare_component "ark" in
    (* Component *)
    do~ M.declare_component "sigmaF" in
    (* Component *)
    do~ M.declare_component "sigmaP" in
    (* Component *)
    do~ M.declare_component "mix" in
    (* Component *)
    do~ M.declare_component "mixS" in
    (* Component *)
    do~ M.declare_component "mixLast" in
    do~ M.substitute_var "ark" [Access.Array (0)] [[ M.call_function ~(| "Ark", [ M.var (| "t" |); M.var (| "C" |); 0 ] |) ]] in
    (* Var *)
    do~ M.declare_var "j" [[ ([] : list F.t) ]] in
    do~ M.substitute_var "j" [] [[ 0 ]] in
    do~ M.while [[ InfixOp.lesser ~(| M.var (| "j" |), M.var (| "t" |) |) ]] (
      do~ M.if_ [[ InfixOp.greater ~(| M.var (| "j" |), 0 |) ]] (* then *) (
        do~ M.substitute_var "ark" [Access.Array (0); Access.Component "in"; Access.Array (M.var (| "j" |))] [[ M.var_access (| "inputs", [Access.Array (InfixOp.sub ~(| M.var (| "j" |), 1 |))] |) ]] in
        M.pure BlockUnit.Tt
      ) (* else *) (
        do~ M.substitute_var "ark" [Access.Array (0); Access.Component "in"; Access.Array (M.var (| "j" |))] [[ M.var (| "initialState" |) ]] in
        M.pure BlockUnit.Tt
      ) in
      do~ M.substitute_var "j" [] [[ InfixOp.add ~(| M.var (| "j" |), 1 |) ]] in
      M.pure BlockUnit.Tt
    ) in
    (* Var *)
    do~ M.declare_var "r" [[ ([] : list F.t) ]] in
    do~ M.substitute_var "r" [] [[ 0 ]] in
    do~ M.while [[ InfixOp.lesser ~(| M.var (| "r" |), InfixOp.sub ~(| InfixOp.intDiv ~(| M.var (| "nRoundsF" |), 2 |), 1 |) |) ]] (
      (* Var *)
      do~ M.declare_var "j" [[ ([] : list F.t) ]] in
      do~ M.substitute_var "j" [] [[ 0 ]] in
      do~ M.while [[ InfixOp.lesser ~(| M.var (| "j" |), M.var (| "t" |) |) ]] (
        do~ M.substitute_var "sigmaF" [Access.Array (M.var (| "r" |)); Access.Array (M.var (| "j" |))] [[ M.call_function ~(| "Sigma", ([] : list F.t) |) ]] in
        do~ M.if_ [[ InfixOp.eq ~(| M.var (| "r" |), 0 |) ]] (* then *) (
          do~ M.substitute_var "sigmaF" [Access.Array (M.var (| "r" |)); Access.Array (M.var (| "j" |)); Access.Component "in"] [[ M.var_access (| "ark", [Access.Array (0); Access.Component "out"; Access.Array (M.var (| "j" |))] |) ]] in
          M.pure BlockUnit.Tt
        ) (* else *) (
          do~ M.substitute_var "sigmaF" [Access.Array (M.var (| "r" |)); Access.Array (M.var (| "j" |)); Access.Component "in"] [[ M.var_access (| "mix", [Access.Array (InfixOp.sub ~(| M.var (| "r" |), 1 |)); Access.Component "out"; Access.Array (M.var (| "j" |))] |) ]] in
          M.pure BlockUnit.Tt
        ) in
        do~ M.substitute_var "j" [] [[ InfixOp.add ~(| M.var (| "j" |), 1 |) ]] in
        M.pure BlockUnit.Tt
      ) in
      do~ M.substitute_var "ark" [Access.Array (InfixOp.add ~(| M.var (| "r" |), 1 |))] [[ M.call_function ~(| "Ark", [ M.var (| "t" |); M.var (| "C" |); InfixOp.mul ~(| InfixOp.add ~(| M.var (| "r" |), 1 |), M.var (| "t" |) |) ] |) ]] in
      (* Var *)
      do~ M.declare_var "j" [[ ([] : list F.t) ]] in
      do~ M.substitute_var "j" [] [[ 0 ]] in
      do~ M.while [[ InfixOp.lesser ~(| M.var (| "j" |), M.var (| "t" |) |) ]] (
        do~ M.substitute_var "ark" [Access.Array (InfixOp.add ~(| M.var (| "r" |), 1 |)); Access.Component "in"; Access.Array (M.var (| "j" |))] [[ M.var_access (| "sigmaF", [Access.Array (M.var (| "r" |)); Access.Array (M.var (| "j" |)); Access.Component "out"] |) ]] in
        do~ M.substitute_var "j" [] [[ InfixOp.add ~(| M.var (| "j" |), 1 |) ]] in
        M.pure BlockUnit.Tt
      ) in
      do~ M.substitute_var "mix" [Access.Array (M.var (| "r" |))] [[ M.call_function ~(| "Mix", [ M.var (| "t" |); M.var (| "M" |) ] |) ]] in
      (* Var *)
      do~ M.declare_var "j" [[ ([] : list F.t) ]] in
      do~ M.substitute_var "j" [] [[ 0 ]] in
      do~ M.while [[ InfixOp.lesser ~(| M.var (| "j" |), M.var (| "t" |) |) ]] (
        do~ M.substitute_var "mix" [Access.Array (M.var (| "r" |)); Access.Component "in"; Access.Array (M.var (| "j" |))] [[ M.var_access (| "ark", [Access.Array (InfixOp.add ~(| M.var (| "r" |), 1 |)); Access.Component "out"; Access.Array (M.var (| "j" |))] |) ]] in
        do~ M.substitute_var "j" [] [[ InfixOp.add ~(| M.var (| "j" |), 1 |) ]] in
        M.pure BlockUnit.Tt
      ) in
      do~ M.substitute_var "r" [] [[ InfixOp.add ~(| M.var (| "r" |), 1 |) ]] in
      M.pure BlockUnit.Tt
    ) in
    (* Var *)
    do~ M.declare_var "j" [[ ([] : list F.t) ]] in
    do~ M.substitute_var "j" [] [[ 0 ]] in
    do~ M.while [[ InfixOp.lesser ~(| M.var (| "j" |), M.var (| "t" |) |) ]] (
      do~ M.substitute_var "sigmaF" [Access.Array (InfixOp.sub ~(| InfixOp.intDiv ~(| M.var (| "nRoundsF" |), 2 |), 1 |)); Access.Array (M.var (| "j" |))] [[ M.call_function ~(| "Sigma", ([] : list F.t) |) ]] in
      do~ M.substitute_var "sigmaF" [Access.Array (InfixOp.sub ~(| InfixOp.intDiv ~(| M.var (| "nRoundsF" |), 2 |), 1 |)); Access.Array (M.var (| "j" |)); Access.Component "in"] [[ M.var_access (| "mix", [Access.Array (InfixOp.sub ~(| InfixOp.intDiv ~(| M.var (| "nRoundsF" |), 2 |), 2 |)); Access.Component "out"; Access.Array (M.var (| "j" |))] |) ]] in
      do~ M.substitute_var "j" [] [[ InfixOp.add ~(| M.var (| "j" |), 1 |) ]] in
      M.pure BlockUnit.Tt
    ) in
    do~ M.substitute_var "ark" [Access.Array (InfixOp.intDiv ~(| M.var (| "nRoundsF" |), 2 |))] [[ M.call_function ~(| "Ark", [ M.var (| "t" |); M.var (| "C" |); InfixOp.mul ~(| InfixOp.intDiv ~(| M.var (| "nRoundsF" |), 2 |), M.var (| "t" |) |) ] |) ]] in
    (* Var *)
    do~ M.declare_var "j" [[ ([] : list F.t) ]] in
    do~ M.substitute_var "j" [] [[ 0 ]] in
    do~ M.while [[ InfixOp.lesser ~(| M.var (| "j" |), M.var (| "t" |) |) ]] (
      do~ M.substitute_var "ark" [Access.Array (InfixOp.intDiv ~(| M.var (| "nRoundsF" |), 2 |)); Access.Component "in"; Access.Array (M.var (| "j" |))] [[ M.var_access (| "sigmaF", [Access.Array (InfixOp.sub ~(| InfixOp.intDiv ~(| M.var (| "nRoundsF" |), 2 |), 1 |)); Access.Array (M.var (| "j" |)); Access.Component "out"] |) ]] in
      do~ M.substitute_var "j" [] [[ InfixOp.add ~(| M.var (| "j" |), 1 |) ]] in
      M.pure BlockUnit.Tt
    ) in
    do~ M.substitute_var "mix" [Access.Array (InfixOp.sub ~(| InfixOp.intDiv ~(| M.var (| "nRoundsF" |), 2 |), 1 |))] [[ M.call_function ~(| "Mix", [ M.var (| "t" |); M.var (| "P" |) ] |) ]] in
    (* Var *)
    do~ M.declare_var "j" [[ ([] : list F.t) ]] in
    do~ M.substitute_var "j" [] [[ 0 ]] in
    do~ M.while [[ InfixOp.lesser ~(| M.var (| "j" |), M.var (| "t" |) |) ]] (
      do~ M.substitute_var "mix" [Access.Array (InfixOp.sub ~(| InfixOp.intDiv ~(| M.var (| "nRoundsF" |), 2 |), 1 |)); Access.Component "in"; Access.Array (M.var (| "j" |))] [[ M.var_access (| "ark", [Access.Array (InfixOp.intDiv ~(| M.var (| "nRoundsF" |), 2 |)); Access.Component "out"; Access.Array (M.var (| "j" |))] |) ]] in
      do~ M.substitute_var "j" [] [[ InfixOp.add ~(| M.var (| "j" |), 1 |) ]] in
      M.pure BlockUnit.Tt
    ) in
    (* Var *)
    do~ M.declare_var "r" [[ ([] : list F.t) ]] in
    do~ M.substitute_var "r" [] [[ 0 ]] in
    do~ M.while [[ InfixOp.lesser ~(| M.var (| "r" |), M.var (| "nRoundsP" |) |) ]] (
      do~ M.substitute_var "sigmaP" [Access.Array (M.var (| "r" |))] [[ M.call_function ~(| "Sigma", ([] : list F.t) |) ]] in
      do~ M.if_ [[ InfixOp.eq ~(| M.var (| "r" |), 0 |) ]] (* then *) (
        do~ M.substitute_var "sigmaP" [Access.Array (M.var (| "r" |)); Access.Component "in"] [[ M.var_access (| "mix", [Access.Array (InfixOp.sub ~(| InfixOp.intDiv ~(| M.var (| "nRoundsF" |), 2 |), 1 |)); Access.Component "out"; Access.Array (0)] |) ]] in
        M.pure BlockUnit.Tt
      ) (* else *) (
        do~ M.substitute_var "sigmaP" [Access.Array (M.var (| "r" |)); Access.Component "in"] [[ M.var_access (| "mixS", [Access.Array (InfixOp.sub ~(| M.var (| "r" |), 1 |)); Access.Component "out"; Access.Array (0)] |) ]] in
        M.pure BlockUnit.Tt
      ) in
      do~ M.substitute_var "mixS" [Access.Array (M.var (| "r" |))] [[ M.call_function ~(| "MixS", [ M.var (| "t" |); M.var (| "S" |); M.var (| "r" |) ] |) ]] in
      (* Var *)
      do~ M.declare_var "j" [[ ([] : list F.t) ]] in
      do~ M.substitute_var "j" [] [[ 0 ]] in
      do~ M.while [[ InfixOp.lesser ~(| M.var (| "j" |), M.var (| "t" |) |) ]] (
        do~ M.if_ [[ InfixOp.eq ~(| M.var (| "j" |), 0 |) ]] (* then *) (
          do~ M.substitute_var "mixS" [Access.Array (M.var (| "r" |)); Access.Component "in"; Access.Array (M.var (| "j" |))] [[ InfixOp.add ~(| M.var_access (| "sigmaP", [Access.Array (M.var (| "r" |)); Access.Component "out"] |), M.var_access (| "C", [Access.Array (InfixOp.add ~(| InfixOp.mul ~(| InfixOp.add ~(| InfixOp.intDiv ~(| M.var (| "nRoundsF" |), 2 |), 1 |), M.var (| "t" |) |), M.var (| "r" |) |))] |) |) ]] in
          M.pure BlockUnit.Tt
        ) (* else *) (
          do~ M.if_ [[ InfixOp.eq ~(| M.var (| "r" |), 0 |) ]] (* then *) (
            do~ M.substitute_var "mixS" [Access.Array (M.var (| "r" |)); Access.Component "in"; Access.Array (M.var (| "j" |))] [[ M.var_access (| "mix", [Access.Array (InfixOp.sub ~(| InfixOp.intDiv ~(| M.var (| "nRoundsF" |), 2 |), 1 |)); Access.Component "out"; Access.Array (M.var (| "j" |))] |) ]] in
            M.pure BlockUnit.Tt
          ) (* else *) (
            do~ M.substitute_var "mixS" [Access.Array (M.var (| "r" |)); Access.Component "in"; Access.Array (M.var (| "j" |))] [[ M.var_access (| "mixS", [Access.Array (InfixOp.sub ~(| M.var (| "r" |), 1 |)); Access.Component "out"; Access.Array (M.var (| "j" |))] |) ]] in
            M.pure BlockUnit.Tt
          ) in
          M.pure BlockUnit.Tt
        ) in
        do~ M.substitute_var "j" [] [[ InfixOp.add ~(| M.var (| "j" |), 1 |) ]] in
        M.pure BlockUnit.Tt
      ) in
      do~ M.substitute_var "r" [] [[ InfixOp.add ~(| M.var (| "r" |), 1 |) ]] in
      M.pure BlockUnit.Tt
    ) in
    (* Var *)
    do~ M.declare_var "r" [[ ([] : list F.t) ]] in
    do~ M.substitute_var "r" [] [[ 0 ]] in
    do~ M.while [[ InfixOp.lesser ~(| M.var (| "r" |), InfixOp.sub ~(| InfixOp.intDiv ~(| M.var (| "nRoundsF" |), 2 |), 1 |) |) ]] (
      (* Var *)
      do~ M.declare_var "j" [[ ([] : list F.t) ]] in
      do~ M.substitute_var "j" [] [[ 0 ]] in
      do~ M.while [[ InfixOp.lesser ~(| M.var (| "j" |), M.var (| "t" |) |) ]] (
        do~ M.substitute_var "sigmaF" [Access.Array (InfixOp.add ~(| InfixOp.intDiv ~(| M.var (| "nRoundsF" |), 2 |), M.var (| "r" |) |)); Access.Array (M.var (| "j" |))] [[ M.call_function ~(| "Sigma", ([] : list F.t) |) ]] in
        do~ M.if_ [[ InfixOp.eq ~(| M.var (| "r" |), 0 |) ]] (* then *) (
          do~ M.substitute_var "sigmaF" [Access.Array (InfixOp.add ~(| InfixOp.intDiv ~(| M.var (| "nRoundsF" |), 2 |), M.var (| "r" |) |)); Access.Array (M.var (| "j" |)); Access.Component "in"] [[ M.var_access (| "mixS", [Access.Array (InfixOp.sub ~(| M.var (| "nRoundsP" |), 1 |)); Access.Component "out"; Access.Array (M.var (| "j" |))] |) ]] in
          M.pure BlockUnit.Tt
        ) (* else *) (
          do~ M.substitute_var "sigmaF" [Access.Array (InfixOp.add ~(| InfixOp.intDiv ~(| M.var (| "nRoundsF" |), 2 |), M.var (| "r" |) |)); Access.Array (M.var (| "j" |)); Access.Component "in"] [[ M.var_access (| "mix", [Access.Array (InfixOp.sub ~(| InfixOp.add ~(| InfixOp.intDiv ~(| M.var (| "nRoundsF" |), 2 |), M.var (| "r" |) |), 1 |)); Access.Component "out"; Access.Array (M.var (| "j" |))] |) ]] in
          M.pure BlockUnit.Tt
        ) in
        do~ M.substitute_var "j" [] [[ InfixOp.add ~(| M.var (| "j" |), 1 |) ]] in
        M.pure BlockUnit.Tt
      ) in
      do~ M.substitute_var "ark" [Access.Array (InfixOp.add ~(| InfixOp.add ~(| InfixOp.intDiv ~(| M.var (| "nRoundsF" |), 2 |), M.var (| "r" |) |), 1 |))] [[ M.call_function ~(| "Ark", [ M.var (| "t" |); M.var (| "C" |); InfixOp.add ~(| InfixOp.add ~(| InfixOp.mul ~(| InfixOp.add ~(| InfixOp.intDiv ~(| M.var (| "nRoundsF" |), 2 |), 1 |), M.var (| "t" |) |), M.var (| "nRoundsP" |) |), InfixOp.mul ~(| M.var (| "r" |), M.var (| "t" |) |) |) ] |) ]] in
      (* Var *)
      do~ M.declare_var "j" [[ ([] : list F.t) ]] in
      do~ M.substitute_var "j" [] [[ 0 ]] in
      do~ M.while [[ InfixOp.lesser ~(| M.var (| "j" |), M.var (| "t" |) |) ]] (
        do~ M.substitute_var "ark" [Access.Array (InfixOp.add ~(| InfixOp.add ~(| InfixOp.intDiv ~(| M.var (| "nRoundsF" |), 2 |), M.var (| "r" |) |), 1 |)); Access.Component "in"; Access.Array (M.var (| "j" |))] [[ M.var_access (| "sigmaF", [Access.Array (InfixOp.add ~(| InfixOp.intDiv ~(| M.var (| "nRoundsF" |), 2 |), M.var (| "r" |) |)); Access.Array (M.var (| "j" |)); Access.Component "out"] |) ]] in
        do~ M.substitute_var "j" [] [[ InfixOp.add ~(| M.var (| "j" |), 1 |) ]] in
        M.pure BlockUnit.Tt
      ) in
      do~ M.substitute_var "mix" [Access.Array (InfixOp.add ~(| InfixOp.intDiv ~(| M.var (| "nRoundsF" |), 2 |), M.var (| "r" |) |))] [[ M.call_function ~(| "Mix", [ M.var (| "t" |); M.var (| "M" |) ] |) ]] in
      (* Var *)
      do~ M.declare_var "j" [[ ([] : list F.t) ]] in
      do~ M.substitute_var "j" [] [[ 0 ]] in
      do~ M.while [[ InfixOp.lesser ~(| M.var (| "j" |), M.var (| "t" |) |) ]] (
        do~ M.substitute_var "mix" [Access.Array (InfixOp.add ~(| InfixOp.intDiv ~(| M.var (| "nRoundsF" |), 2 |), M.var (| "r" |) |)); Access.Component "in"; Access.Array (M.var (| "j" |))] [[ M.var_access (| "ark", [Access.Array (InfixOp.add ~(| InfixOp.add ~(| InfixOp.intDiv ~(| M.var (| "nRoundsF" |), 2 |), M.var (| "r" |) |), 1 |)); Access.Component "out"; Access.Array (M.var (| "j" |))] |) ]] in
        do~ M.substitute_var "j" [] [[ InfixOp.add ~(| M.var (| "j" |), 1 |) ]] in
        M.pure BlockUnit.Tt
      ) in
      do~ M.substitute_var "r" [] [[ InfixOp.add ~(| M.var (| "r" |), 1 |) ]] in
      M.pure BlockUnit.Tt
    ) in
    (* Var *)
    do~ M.declare_var "j" [[ ([] : list F.t) ]] in
    do~ M.substitute_var "j" [] [[ 0 ]] in
    do~ M.while [[ InfixOp.lesser ~(| M.var (| "j" |), M.var (| "t" |) |) ]] (
      do~ M.substitute_var "sigmaF" [Access.Array (InfixOp.sub ~(| M.var (| "nRoundsF" |), 1 |)); Access.Array (M.var (| "j" |))] [[ M.call_function ~(| "Sigma", ([] : list F.t) |) ]] in
      do~ M.substitute_var "sigmaF" [Access.Array (InfixOp.sub ~(| M.var (| "nRoundsF" |), 1 |)); Access.Array (M.var (| "j" |)); Access.Component "in"] [[ M.var_access (| "mix", [Access.Array (InfixOp.sub ~(| M.var (| "nRoundsF" |), 2 |)); Access.Component "out"; Access.Array (M.var (| "j" |))] |) ]] in
      do~ M.substitute_var "j" [] [[ InfixOp.add ~(| M.var (| "j" |), 1 |) ]] in
      M.pure BlockUnit.Tt
    ) in
    (* Var *)
    do~ M.declare_var "i" [[ ([] : list F.t) ]] in
    do~ M.substitute_var "i" [] [[ 0 ]] in
    do~ M.while [[ InfixOp.lesser ~(| M.var (| "i" |), M.var (| "nOuts" |) |) ]] (
      do~ M.substitute_var "mixLast" [Access.Array (M.var (| "i" |))] [[ M.call_function ~(| "MixLast", [ M.var (| "t" |); M.var (| "M" |); M.var (| "i" |) ] |) ]] in
      (* Var *)
      do~ M.declare_var "j" [[ ([] : list F.t) ]] in
      do~ M.substitute_var "j" [] [[ 0 ]] in
      do~ M.while [[ InfixOp.lesser ~(| M.var (| "j" |), M.var (| "t" |) |) ]] (
        do~ M.substitute_var "mixLast" [Access.Array (M.var (| "i" |)); Access.Component "in"; Access.Array (M.var (| "j" |))] [[ M.var_access (| "sigmaF", [Access.Array (InfixOp.sub ~(| M.var (| "nRoundsF" |), 1 |)); Access.Array (M.var (| "j" |)); Access.Component "out"] |) ]] in
        do~ M.substitute_var "j" [] [[ InfixOp.add ~(| M.var (| "j" |), 1 |) ]] in
        M.pure BlockUnit.Tt
      ) in
      do~ M.substitute_var "out" [Access.Array (M.var (| "i" |))] [[ M.var_access (| "mixLast", [Access.Array (M.var (| "i" |)); Access.Component "out"] |) ]] in
      do~ M.substitute_var "i" [] [[ InfixOp.add ~(| M.var (| "i" |), 1 |) ]] in
      M.pure BlockUnit.Tt
    ) in
    M.pure BlockUnit.Tt
  ).

(* Template not under-constrained *)
Definition PoseidonEx_not_under_constrained (nInputs nOuts : F.t) inputs initialState : Prop :=
  exists! out,
  let signals := PoseidonExSignals.Build_t inputs initialState out in
  True (* NotUnderConstrained PoseidonEx nInputs nOuts signals *).

(* Template signals *)
Module PoseidonSignals.
  Record t : Set := {
    (* Input *)
    inputs : list F.t;
    (* Output *)
    out : F.t;
  }.

  Module IsNamed.
    Inductive P : forall (A : Set), (t -> A) -> string -> Prop :=
    | inputs : P _ inputs "inputs"
    | out : P _ out "out".
  End IsNamed.
End PoseidonSignals.

(* Template body *)
Definition Poseidon (nInputs : F.t) : M.t (BlockUnit.t Empty_set) :=
  M.template_body [("nInputs", nInputs)] (
    (* Signal Input *)
    do~ M.declare_signal "inputs" in
    (* Signal Output *)
    do~ M.declare_signal "out" in
    (* Component *)
    do~ M.declare_component "pEx" in
    do~ M.substitute_var "pEx" [] [[ M.call_function ~(| "PoseidonEx", [ M.var (| "nInputs" |); 1 ] |) ]] in
    do~ M.substitute_var "pEx" [Access.Component "initialState"] [[ 0 ]] in
    (* Var *)
    do~ M.declare_var "i" [[ ([] : list F.t) ]] in
    do~ M.substitute_var "i" [] [[ 0 ]] in
    do~ M.while [[ InfixOp.lesser ~(| M.var (| "i" |), M.var (| "nInputs" |) |) ]] (
      do~ M.substitute_var "pEx" [Access.Component "inputs"; Access.Array (M.var (| "i" |))] [[ M.var_access (| "inputs", [Access.Array (M.var (| "i" |))] |) ]] in
      do~ M.substitute_var "i" [] [[ InfixOp.add ~(| M.var (| "i" |), 1 |) ]] in
      M.pure BlockUnit.Tt
    ) in
    do~ M.substitute_var "out" [] [[ M.var_access (| "pEx", [Access.Component "out"; Access.Array (0)] |) ]] in
    M.pure BlockUnit.Tt
  ).

(* Template not under-constrained *)
Definition Poseidon_not_under_constrained (nInputs : F.t) inputs : Prop :=
  exists! out,
  let signals := PoseidonSignals.Build_t inputs out in
  True (* NotUnderConstrained Poseidon nInputs signals *).
