(* Generated by Garden *)
Require Import Garden.Garden.

(* Template signals *)
Module IsZeroSignals.
  Record t : Set := {
    in_ : F.t;
    out : F.t;
    inv : F.t;
  }.
End IsZeroSignals.

(* Template body *)
Definition IsZero : M.t (BlockUnit.t Empty_set) :=
  (* Signal Input *)
  do~ M.declare_signal "in" [[ ([] : list F.t) ]] in
  (* Signal Output *)
  do~ M.declare_signal "out" [[ ([] : list F.t) ]] in
  (* Signal Intermediate *)
  do~ M.declare_signal "inv" [[ ([] : list F.t) ]] in
  do~ M.substitute_var "inv" [[ ternary_expression (InfixOp.notEq ~(| M.var (| "in" |), 0 |)) (InfixOp.div ~(| 1, M.var (| "in" |) |)) (0) ]] in
  do~ M.substitute_var "out" [[ InfixOp.add ~(| InfixOp.mul ~(| PrefixOp.sub ~(| M.var (| "in" |) |), M.var (| "inv" |) |), 1 |) ]] in
  do~ M.equality_constraint
    [[ InfixOp.mul ~(| M.var (| "in" |), M.var (| "out" |) |) ]]
    [[ 0 ]]
  in
  M.pure BlockUnit.Tt.

(* Template signals *)
Module IsEqualSignals.
  Record t : Set := {
    in_ : list F.t;
    out : F.t;
  }.
End IsEqualSignals.

(* Template body *)
Definition IsEqual : M.t (BlockUnit.t Empty_set) :=
  (* Signal Input *)
  do~ M.declare_signal "in" [[ [ 2 ] ]] in
  (* Signal Output *)
  do~ M.declare_signal "out" [[ ([] : list F.t) ]] in
  (* Component *)
  do~ M.declare_component "isz" in
  do~ M.substitute_var "isz" [[ M.call_function ~(| "IsZero", ([] : list F.t) |) ]] in
  do~ M.substitute_var "isz" [[ InfixOp.sub ~(| M.var_access (| "in", [Access.Array (1)] |), M.var_access (| "in", [Access.Array (0)] |) |) ]] in
  do~ M.substitute_var "out" [[ M.var_access (| "isz", [Access.Component "out"] |) ]] in
  M.pure BlockUnit.Tt.

(* Template signals *)
Module ForceEqualIfEnabledSignals.
  Record t : Set := {
    enabled : F.t;
    in_ : list F.t;
  }.
End ForceEqualIfEnabledSignals.

(* Template body *)
Definition ForceEqualIfEnabled : M.t (BlockUnit.t Empty_set) :=
  (* Signal Input *)
  do~ M.declare_signal "enabled" [[ ([] : list F.t) ]] in
  (* Signal Input *)
  do~ M.declare_signal "in" [[ [ 2 ] ]] in
  (* Component *)
  do~ M.declare_component "isz" in
  do~ M.substitute_var "isz" [[ M.call_function ~(| "IsZero", ([] : list F.t) |) ]] in
  do~ M.substitute_var "isz" [[ InfixOp.sub ~(| M.var_access (| "in", [Access.Array (1)] |), M.var_access (| "in", [Access.Array (0)] |) |) ]] in
  do~ M.equality_constraint
    [[ InfixOp.mul ~(| InfixOp.sub ~(| 1, M.var_access (| "isz", [Access.Component "out"] |) |), M.var (| "enabled" |) |) ]]
    [[ 0 ]]
  in
  M.pure BlockUnit.Tt.

(* Template signals *)
Module LessThanSignals.
  Record t : Set := {
    in_ : list F.t;
    out : F.t;
  }.
End LessThanSignals.

(* Template body *)
Definition LessThan (n : F.t) : M.t (BlockUnit.t Empty_set) :=
  do~ M.assert [[ InfixOp.lesserEq ~(| M.var (| "n" |), 252 |) ]] in
  (* Signal Input *)
  do~ M.declare_signal "in" [[ [ 2 ] ]] in
  (* Signal Output *)
  do~ M.declare_signal "out" [[ ([] : list F.t) ]] in
  (* Component *)
  do~ M.declare_component "n2b" in
  do~ M.substitute_var "n2b" [[ M.call_function ~(| "Num2Bits", [ InfixOp.add ~(| M.var (| "n" |), 1 |) ] |) ]] in
  do~ M.substitute_var "n2b" [[ InfixOp.sub ~(| InfixOp.add ~(| M.var_access (| "in", [Access.Array (0)] |), InfixOp.shiftL ~(| 1, M.var (| "n" |) |) |), M.var_access (| "in", [Access.Array (1)] |) |) ]] in
  do~ M.substitute_var "out" [[ InfixOp.sub ~(| 1, M.var_access (| "n2b", [Access.Component "out"; Access.Array (M.var (| "n" |))] |) |) ]] in
  M.pure BlockUnit.Tt.

(* Template signals *)
Module LessEqThanSignals.
  Record t : Set := {
    in_ : list F.t;
    out : F.t;
  }.
End LessEqThanSignals.

(* Template body *)
Definition LessEqThan (n : F.t) : M.t (BlockUnit.t Empty_set) :=
  (* Signal Input *)
  do~ M.declare_signal "in" [[ [ 2 ] ]] in
  (* Signal Output *)
  do~ M.declare_signal "out" [[ ([] : list F.t) ]] in
  (* Component *)
  do~ M.declare_component "lt" in
  do~ M.substitute_var "lt" [[ M.call_function ~(| "LessThan", [ M.var (| "n" |) ] |) ]] in
  do~ M.substitute_var "lt" [[ M.var_access (| "in", [Access.Array (0)] |) ]] in
  do~ M.substitute_var "lt" [[ InfixOp.add ~(| M.var_access (| "in", [Access.Array (1)] |), 1 |) ]] in
  do~ M.substitute_var "out" [[ M.var_access (| "lt", [Access.Component "out"] |) ]] in
  M.pure BlockUnit.Tt.

(* Template signals *)
Module GreaterThanSignals.
  Record t : Set := {
    in_ : list F.t;
    out : F.t;
  }.
End GreaterThanSignals.

(* Template body *)
Definition GreaterThan (n : F.t) : M.t (BlockUnit.t Empty_set) :=
  (* Signal Input *)
  do~ M.declare_signal "in" [[ [ 2 ] ]] in
  (* Signal Output *)
  do~ M.declare_signal "out" [[ ([] : list F.t) ]] in
  (* Component *)
  do~ M.declare_component "lt" in
  do~ M.substitute_var "lt" [[ M.call_function ~(| "LessThan", [ M.var (| "n" |) ] |) ]] in
  do~ M.substitute_var "lt" [[ M.var_access (| "in", [Access.Array (1)] |) ]] in
  do~ M.substitute_var "lt" [[ M.var_access (| "in", [Access.Array (0)] |) ]] in
  do~ M.substitute_var "out" [[ M.var_access (| "lt", [Access.Component "out"] |) ]] in
  M.pure BlockUnit.Tt.

(* Template signals *)
Module GreaterEqThanSignals.
  Record t : Set := {
    in_ : list F.t;
    out : F.t;
  }.
End GreaterEqThanSignals.

(* Template body *)
Definition GreaterEqThan (n : F.t) : M.t (BlockUnit.t Empty_set) :=
  (* Signal Input *)
  do~ M.declare_signal "in" [[ [ 2 ] ]] in
  (* Signal Output *)
  do~ M.declare_signal "out" [[ ([] : list F.t) ]] in
  (* Component *)
  do~ M.declare_component "lt" in
  do~ M.substitute_var "lt" [[ M.call_function ~(| "LessThan", [ M.var (| "n" |) ] |) ]] in
  do~ M.substitute_var "lt" [[ M.var_access (| "in", [Access.Array (1)] |) ]] in
  do~ M.substitute_var "lt" [[ InfixOp.add ~(| M.var_access (| "in", [Access.Array (0)] |), 1 |) ]] in
  do~ M.substitute_var "out" [[ M.var_access (| "lt", [Access.Component "out"] |) ]] in
  M.pure BlockUnit.Tt.
