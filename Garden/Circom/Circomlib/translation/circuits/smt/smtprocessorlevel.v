(* Generated by Garden *)
Require Import Garden.Garden.

(* Template signals *)
Module SMTProcessorLevelSignals.
  Record t : Set := {
    (* Input *)
    st_top : F.t;
    (* Input *)
    st_old0 : F.t;
    (* Input *)
    st_bot : F.t;
    (* Input *)
    st_new1 : F.t;
    (* Input *)
    st_na : F.t;
    (* Input *)
    st_upd : F.t;
    (* Output *)
    oldRoot : F.t;
    (* Output *)
    newRoot : F.t;
    (* Input *)
    sibling : F.t;
    (* Input *)
    old1leaf : F.t;
    (* Input *)
    new1leaf : F.t;
    (* Input *)
    newlrbit : F.t;
    (* Input *)
    oldChild : F.t;
    (* Input *)
    newChild : F.t;
    (* Intermediate *)
    aux : list F.t;
  }.

  Module IsNamed.
    Inductive P : forall (A : Set), (t -> A) -> string -> Prop :=
    | st_top : P _ st_top "st_top"
    | st_old0 : P _ st_old0 "st_old0"
    | st_bot : P _ st_bot "st_bot"
    | st_new1 : P _ st_new1 "st_new1"
    | st_na : P _ st_na "st_na"
    | st_upd : P _ st_upd "st_upd"
    | oldRoot : P _ oldRoot "oldRoot"
    | newRoot : P _ newRoot "newRoot"
    | sibling : P _ sibling "sibling"
    | old1leaf : P _ old1leaf "old1leaf"
    | new1leaf : P _ new1leaf "new1leaf"
    | newlrbit : P _ newlrbit "newlrbit"
    | oldChild : P _ oldChild "oldChild"
    | newChild : P _ newChild "newChild"
    | aux : P _ aux "aux".
  End IsNamed.
End SMTProcessorLevelSignals.

(* Template body *)
Definition SMTProcessorLevel : M.t (BlockUnit.t Empty_set) :=
  M.template_body [] (
    (* Signal Input *)
    do~ M.declare_signal "st_top" in
    (* Signal Input *)
    do~ M.declare_signal "st_old0" in
    (* Signal Input *)
    do~ M.declare_signal "st_bot" in
    (* Signal Input *)
    do~ M.declare_signal "st_new1" in
    (* Signal Input *)
    do~ M.declare_signal "st_na" in
    (* Signal Input *)
    do~ M.declare_signal "st_upd" in
    (* Signal Output *)
    do~ M.declare_signal "oldRoot" in
    (* Signal Output *)
    do~ M.declare_signal "newRoot" in
    (* Signal Input *)
    do~ M.declare_signal "sibling" in
    (* Signal Input *)
    do~ M.declare_signal "old1leaf" in
    (* Signal Input *)
    do~ M.declare_signal "new1leaf" in
    (* Signal Input *)
    do~ M.declare_signal "newlrbit" in
    (* Signal Input *)
    do~ M.declare_signal "oldChild" in
    (* Signal Input *)
    do~ M.declare_signal "newChild" in
    (* Signal Intermediate *)
    do~ M.declare_signal "aux" in
    (* Component *)
    do~ M.declare_component "oldProofHash" in
    do~ M.substitute_var "oldProofHash" [] [[ M.call_function ~(| "SMTHash2", ([] : list F.t) |) ]] in
    (* Component *)
    do~ M.declare_component "newProofHash" in
    do~ M.substitute_var "newProofHash" [] [[ M.call_function ~(| "SMTHash2", ([] : list F.t) |) ]] in
    (* Component *)
    do~ M.declare_component "oldSwitcher" in
    do~ M.substitute_var "oldSwitcher" [] [[ M.call_function ~(| "Switcher", ([] : list F.t) |) ]] in
    (* Component *)
    do~ M.declare_component "newSwitcher" in
    do~ M.substitute_var "newSwitcher" [] [[ M.call_function ~(| "Switcher", ([] : list F.t) |) ]] in
    do~ M.substitute_var "oldSwitcher" [Access.Component "L"] [[ M.var (| "oldChild" |) ]] in
    do~ M.substitute_var "oldSwitcher" [Access.Component "R"] [[ M.var (| "sibling" |) ]] in
    do~ M.substitute_var "oldSwitcher" [Access.Component "sel"] [[ M.var (| "newlrbit" |) ]] in
    do~ M.substitute_var "oldProofHash" [Access.Component "L"] [[ M.var_access (| "oldSwitcher", [Access.Component "outL"] |) ]] in
    do~ M.substitute_var "oldProofHash" [Access.Component "R"] [[ M.var_access (| "oldSwitcher", [Access.Component "outR"] |) ]] in
    do~ M.substitute_var "aux" [Access.Array (0)] [[ InfixOp.mul ~(| M.var (| "old1leaf" |), InfixOp.add ~(| InfixOp.add ~(| M.var (| "st_bot" |), M.var (| "st_new1" |) |), M.var (| "st_upd" |) |) |) ]] in
    do~ M.substitute_var "oldRoot" [] [[ InfixOp.add ~(| M.var_access (| "aux", [Access.Array (0)] |), InfixOp.mul ~(| M.var_access (| "oldProofHash", [Access.Component "out"] |), M.var (| "st_top" |) |) |) ]] in
    do~ M.substitute_var "aux" [Access.Array (1)] [[ InfixOp.mul ~(| M.var (| "newChild" |), InfixOp.add ~(| M.var (| "st_top" |), M.var (| "st_bot" |) |) |) ]] in
    do~ M.substitute_var "newSwitcher" [Access.Component "L"] [[ InfixOp.add ~(| M.var_access (| "aux", [Access.Array (1)] |), InfixOp.mul ~(| M.var (| "new1leaf" |), M.var (| "st_new1" |) |) |) ]] in
    do~ M.substitute_var "aux" [Access.Array (2)] [[ InfixOp.mul ~(| M.var (| "sibling" |), M.var (| "st_top" |) |) ]] in
    do~ M.substitute_var "newSwitcher" [Access.Component "R"] [[ InfixOp.add ~(| M.var_access (| "aux", [Access.Array (2)] |), InfixOp.mul ~(| M.var (| "old1leaf" |), M.var (| "st_new1" |) |) |) ]] in
    do~ M.substitute_var "newSwitcher" [Access.Component "sel"] [[ M.var (| "newlrbit" |) ]] in
    do~ M.substitute_var "newProofHash" [Access.Component "L"] [[ M.var_access (| "newSwitcher", [Access.Component "outL"] |) ]] in
    do~ M.substitute_var "newProofHash" [Access.Component "R"] [[ M.var_access (| "newSwitcher", [Access.Component "outR"] |) ]] in
    do~ M.substitute_var "aux" [Access.Array (3)] [[ InfixOp.mul ~(| M.var_access (| "newProofHash", [Access.Component "out"] |), InfixOp.add ~(| InfixOp.add ~(| M.var (| "st_top" |), M.var (| "st_bot" |) |), M.var (| "st_new1" |) |) |) ]] in
    do~ M.substitute_var "newRoot" [] [[ InfixOp.add ~(| M.var_access (| "aux", [Access.Array (3)] |), InfixOp.mul ~(| M.var (| "new1leaf" |), InfixOp.add ~(| M.var (| "st_old0" |), M.var (| "st_upd" |) |) |) |) ]] in
    M.pure BlockUnit.Tt
  ).

(* Template not under-constrained *)
Definition SMTProcessorLevel_not_under_constrained st_top st_old0 st_bot st_new1 st_na st_upd sibling old1leaf new1leaf newlrbit oldChild newChild : Prop :=
  exists! oldRoot newRoot,
  exists aux,
  let signals := SMTProcessorLevelSignals.Build_t st_top st_old0 st_bot st_new1 st_na st_upd oldRoot newRoot sibling old1leaf new1leaf newlrbit oldChild newChild aux in
  True (* NotUnderConstrained SMTProcessorLevel signals *).
