(* Generated by Garden *)
Require Import Garden.Garden.

(* Template signals *)
Module SMTVerifierLevelSignals.
  Record t : Set := {
    (* Input *)
    st_top : F.t;
    (* Input *)
    st_i0 : F.t;
    (* Input *)
    st_iold : F.t;
    (* Input *)
    st_inew : F.t;
    (* Input *)
    st_na : F.t;
    (* Output *)
    root : F.t;
    (* Input *)
    sibling : F.t;
    (* Input *)
    old1leaf : F.t;
    (* Input *)
    new1leaf : F.t;
    (* Input *)
    lrbit : F.t;
    (* Input *)
    child : F.t;
    (* Intermediate *)
    aux : list F.t;
  }.
End SMTVerifierLevelSignals.

(* Template body *)
Definition SMTVerifierLevel : M.t (BlockUnit.t Empty_set) :=
  M.template_body [] (
    (* Signal Input *)
    do~ M.declare_signal "st_top" [[ ([] : list F.t) ]] in
    (* Signal Input *)
    do~ M.declare_signal "st_i0" [[ ([] : list F.t) ]] in
    (* Signal Input *)
    do~ M.declare_signal "st_iold" [[ ([] : list F.t) ]] in
    (* Signal Input *)
    do~ M.declare_signal "st_inew" [[ ([] : list F.t) ]] in
    (* Signal Input *)
    do~ M.declare_signal "st_na" [[ ([] : list F.t) ]] in
    (* Signal Output *)
    do~ M.declare_signal "root" [[ ([] : list F.t) ]] in
    (* Signal Input *)
    do~ M.declare_signal "sibling" [[ ([] : list F.t) ]] in
    (* Signal Input *)
    do~ M.declare_signal "old1leaf" [[ ([] : list F.t) ]] in
    (* Signal Input *)
    do~ M.declare_signal "new1leaf" [[ ([] : list F.t) ]] in
    (* Signal Input *)
    do~ M.declare_signal "lrbit" [[ ([] : list F.t) ]] in
    (* Signal Input *)
    do~ M.declare_signal "child" [[ ([] : list F.t) ]] in
    (* Signal Intermediate *)
    do~ M.declare_signal "aux" [[ [ 2 ] ]] in
    (* Component *)
    do~ M.declare_component "proofHash" in
    do~ M.substitute_var "proofHash" [[ M.call_function ~(| "SMTHash2", ([] : list F.t) |) ]] in
    (* Component *)
    do~ M.declare_component "switcher" in
    do~ M.substitute_var "switcher" [[ M.call_function ~(| "Switcher", ([] : list F.t) |) ]] in
    do~ M.substitute_var "switcher" [[ M.var (| "child" |) ]] in
    do~ M.substitute_var "switcher" [[ M.var (| "sibling" |) ]] in
    do~ M.substitute_var "switcher" [[ M.var (| "lrbit" |) ]] in
    do~ M.substitute_var "proofHash" [[ M.var_access (| "switcher", [Access.Component "outL"] |) ]] in
    do~ M.substitute_var "proofHash" [[ M.var_access (| "switcher", [Access.Component "outR"] |) ]] in
    do~ M.substitute_var "aux" [[ InfixOp.mul ~(| M.var_access (| "proofHash", [Access.Component "out"] |), M.var (| "st_top" |) |) ]] in
    do~ M.substitute_var "aux" [[ InfixOp.mul ~(| M.var (| "old1leaf" |), M.var (| "st_iold" |) |) ]] in
    do~ M.substitute_var "root" [[ InfixOp.add ~(| InfixOp.add ~(| M.var_access (| "aux", [Access.Array (0)] |), M.var_access (| "aux", [Access.Array (1)] |) |), InfixOp.mul ~(| M.var (| "new1leaf" |), M.var (| "st_inew" |) |) |) ]] in
    M.pure BlockUnit.Tt
  ).

(* Template not under-constrained *)
Definition SMTVerifierLevel_not_under_constrained st_top st_i0 st_iold st_inew st_na sibling old1leaf new1leaf lrbit child : Prop :=
  exists! root,
  exists aux,
  let signals := SMTVerifierLevelSignals.Build_t st_top st_i0 st_iold st_inew st_na root sibling old1leaf new1leaf lrbit child aux in
  True (* NotUnderConstrained SMTVerifierLevel signals *).
