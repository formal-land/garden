(* Generated by Garden *)
Require Import Garden.Garden.

(* Template signals *)
Module SMTProcessorSignals.
  Record t : Set := {
    (* Input *)
    oldRoot : F.t;
    (* Output *)
    newRoot : F.t;
    (* Input *)
    siblings : list F.t;
    (* Input *)
    oldKey : F.t;
    (* Input *)
    oldValue : F.t;
    (* Input *)
    isOld0 : F.t;
    (* Input *)
    newKey : F.t;
    (* Input *)
    newValue : F.t;
    (* Input *)
    fnc : list F.t;
    (* Intermediate *)
    enabled : F.t;
  }.
End SMTProcessorSignals.

(* Template body *)
Definition SMTProcessor (nLevels : F.t) : M.t (BlockUnit.t Empty_set) :=
  M.template_body [("nLevels", nLevels)] (
    (* Signal Input *)
    do~ M.declare_signal "oldRoot" [[ ([] : list F.t) ]] in
    (* Signal Output *)
    do~ M.declare_signal "newRoot" [[ ([] : list F.t) ]] in
    (* Signal Input *)
    do~ M.declare_signal "siblings" [[ [ M.var (| "nLevels" |) ] ]] in
    (* Signal Input *)
    do~ M.declare_signal "oldKey" [[ ([] : list F.t) ]] in
    (* Signal Input *)
    do~ M.declare_signal "oldValue" [[ ([] : list F.t) ]] in
    (* Signal Input *)
    do~ M.declare_signal "isOld0" [[ ([] : list F.t) ]] in
    (* Signal Input *)
    do~ M.declare_signal "newKey" [[ ([] : list F.t) ]] in
    (* Signal Input *)
    do~ M.declare_signal "newValue" [[ ([] : list F.t) ]] in
    (* Signal Input *)
    do~ M.declare_signal "fnc" [[ [ 2 ] ]] in
    (* Signal Intermediate *)
    do~ M.declare_signal "enabled" [[ ([] : list F.t) ]] in
    (* Var *)
    do~ M.declare_var "i" [[ ([] : list F.t) ]] in
    do~ M.substitute_var "i" [[ 0 ]] in
    do~ M.substitute_var "enabled" [[ InfixOp.sub ~(| InfixOp.add ~(| M.var_access (| "fnc", [Access.Array (0)] |), M.var_access (| "fnc", [Access.Array (1)] |) |), InfixOp.mul ~(| M.var_access (| "fnc", [Access.Array (0)] |), M.var_access (| "fnc", [Access.Array (1)] |) |) |) ]] in
    (* Component *)
    do~ M.declare_component "hash1Old" in
    do~ M.substitute_var "hash1Old" [[ M.call_function ~(| "SMTHash1", ([] : list F.t) |) ]] in
    do~ M.substitute_var "hash1Old" [[ M.var (| "oldKey" |) ]] in
    do~ M.substitute_var "hash1Old" [[ M.var (| "oldValue" |) ]] in
    (* Component *)
    do~ M.declare_component "hash1New" in
    do~ M.substitute_var "hash1New" [[ M.call_function ~(| "SMTHash1", ([] : list F.t) |) ]] in
    do~ M.substitute_var "hash1New" [[ M.var (| "newKey" |) ]] in
    do~ M.substitute_var "hash1New" [[ M.var (| "newValue" |) ]] in
    (* Component *)
    do~ M.declare_component "n2bOld" in
    do~ M.substitute_var "n2bOld" [[ M.call_function ~(| "Num2Bits_strict", ([] : list F.t) |) ]] in
    (* Component *)
    do~ M.declare_component "n2bNew" in
    do~ M.substitute_var "n2bNew" [[ M.call_function ~(| "Num2Bits_strict", ([] : list F.t) |) ]] in
    do~ M.substitute_var "n2bOld" [[ M.var (| "oldKey" |) ]] in
    do~ M.substitute_var "n2bNew" [[ M.var (| "newKey" |) ]] in
    (* Component *)
    do~ M.declare_component "smtLevIns" in
    do~ M.substitute_var "smtLevIns" [[ M.call_function ~(| "SMTLevIns", [ M.var (| "nLevels" |) ] |) ]] in
    do~ M.substitute_var "i" [[ 0 ]] in
    do~ M.while [[ InfixOp.lesser ~(| M.var (| "i" |), M.var (| "nLevels" |) |) ]] (
      do~ M.substitute_var "smtLevIns" [[ M.var_access (| "siblings", [Access.Array (M.var (| "i" |))] |) ]] in
      do~ M.substitute_var "i" [[ InfixOp.add ~(| M.var (| "i" |), 1 |) ]] in
      M.pure BlockUnit.Tt
    ) in
    do~ M.substitute_var "smtLevIns" [[ M.var (| "enabled" |) ]] in
    (* Component *)
    do~ M.declare_component "xors" in
    do~ M.substitute_var "i" [[ 0 ]] in
    do~ M.while [[ InfixOp.lesser ~(| M.var (| "i" |), M.var (| "nLevels" |) |) ]] (
      do~ M.substitute_var "xors" [[ M.call_function ~(| "XOR", ([] : list F.t) |) ]] in
      do~ M.substitute_var "xors" [[ M.var_access (| "n2bOld", [Access.Component "out"; Access.Array (M.var (| "i" |))] |) ]] in
      do~ M.substitute_var "xors" [[ M.var_access (| "n2bNew", [Access.Component "out"; Access.Array (M.var (| "i" |))] |) ]] in
      do~ M.substitute_var "i" [[ InfixOp.add ~(| M.var (| "i" |), 1 |) ]] in
      M.pure BlockUnit.Tt
    ) in
    (* Component *)
    do~ M.declare_component "sm" in
    do~ M.substitute_var "i" [[ 0 ]] in
    do~ M.while [[ InfixOp.lesser ~(| M.var (| "i" |), M.var (| "nLevels" |) |) ]] (
      do~ M.substitute_var "sm" [[ M.call_function ~(| "SMTProcessorSM", ([] : list F.t) |) ]] in
      do~ M.if_ [[ InfixOp.eq ~(| M.var (| "i" |), 0 |) ]] (* then *) (
        do~ M.substitute_var "sm" [[ M.var (| "enabled" |) ]] in
        do~ M.substitute_var "sm" [[ 0 ]] in
        do~ M.substitute_var "sm" [[ 0 ]] in
        do~ M.substitute_var "sm" [[ 0 ]] in
        do~ M.substitute_var "sm" [[ InfixOp.sub ~(| 1, M.var (| "enabled" |) |) ]] in
        do~ M.substitute_var "sm" [[ 0 ]] in
        M.pure BlockUnit.Tt
      ) (* else *) (
        do~ M.substitute_var "sm" [[ M.var_access (| "sm", [Access.Array (InfixOp.sub ~(| M.var (| "i" |), 1 |)); Access.Component "st_top"] |) ]] in
        do~ M.substitute_var "sm" [[ M.var_access (| "sm", [Access.Array (InfixOp.sub ~(| M.var (| "i" |), 1 |)); Access.Component "st_old0"] |) ]] in
        do~ M.substitute_var "sm" [[ M.var_access (| "sm", [Access.Array (InfixOp.sub ~(| M.var (| "i" |), 1 |)); Access.Component "st_bot"] |) ]] in
        do~ M.substitute_var "sm" [[ M.var_access (| "sm", [Access.Array (InfixOp.sub ~(| M.var (| "i" |), 1 |)); Access.Component "st_new1"] |) ]] in
        do~ M.substitute_var "sm" [[ M.var_access (| "sm", [Access.Array (InfixOp.sub ~(| M.var (| "i" |), 1 |)); Access.Component "st_na"] |) ]] in
        do~ M.substitute_var "sm" [[ M.var_access (| "sm", [Access.Array (InfixOp.sub ~(| M.var (| "i" |), 1 |)); Access.Component "st_upd"] |) ]] in
        M.pure BlockUnit.Tt
      ) in
      do~ M.substitute_var "sm" [[ M.var (| "isOld0" |) ]] in
      do~ M.substitute_var "sm" [[ M.var_access (| "xors", [Access.Array (M.var (| "i" |)); Access.Component "out"] |) ]] in
      do~ M.substitute_var "sm" [[ M.var_access (| "fnc", [Access.Array (0)] |) ]] in
      do~ M.substitute_var "sm" [[ M.var_access (| "fnc", [Access.Array (1)] |) ]] in
      do~ M.substitute_var "sm" [[ M.var_access (| "smtLevIns", [Access.Component "levIns"; Access.Array (M.var (| "i" |))] |) ]] in
      do~ M.substitute_var "i" [[ InfixOp.add ~(| M.var (| "i" |), 1 |) ]] in
      M.pure BlockUnit.Tt
    ) in
    do~ M.equality_constraint
      [[ InfixOp.add ~(| InfixOp.add ~(| InfixOp.add ~(| M.var_access (| "sm", [Access.Array (InfixOp.sub ~(| M.var (| "nLevels" |), 1 |)); Access.Component "st_na"] |), M.var_access (| "sm", [Access.Array (InfixOp.sub ~(| M.var (| "nLevels" |), 1 |)); Access.Component "st_new1"] |) |), M.var_access (| "sm", [Access.Array (InfixOp.sub ~(| M.var (| "nLevels" |), 1 |)); Access.Component "st_old0"] |) |), M.var_access (| "sm", [Access.Array (InfixOp.sub ~(| M.var (| "nLevels" |), 1 |)); Access.Component "st_upd"] |) |) ]]
      [[ 1 ]]
    in
    (* Component *)
    do~ M.declare_component "levels" in
    do~ M.substitute_var "i" [[ InfixOp.sub ~(| M.var (| "nLevels" |), 1 |) ]] in
    do~ M.while [[ InfixOp.notEq ~(| M.var (| "i" |), PrefixOp.sub ~(| 1 |) |) ]] (
      do~ M.substitute_var "levels" [[ M.call_function ~(| "SMTProcessorLevel", ([] : list F.t) |) ]] in
      do~ M.substitute_var "levels" [[ M.var_access (| "sm", [Access.Array (M.var (| "i" |)); Access.Component "st_top"] |) ]] in
      do~ M.substitute_var "levels" [[ M.var_access (| "sm", [Access.Array (M.var (| "i" |)); Access.Component "st_old0"] |) ]] in
      do~ M.substitute_var "levels" [[ M.var_access (| "sm", [Access.Array (M.var (| "i" |)); Access.Component "st_bot"] |) ]] in
      do~ M.substitute_var "levels" [[ M.var_access (| "sm", [Access.Array (M.var (| "i" |)); Access.Component "st_new1"] |) ]] in
      do~ M.substitute_var "levels" [[ M.var_access (| "sm", [Access.Array (M.var (| "i" |)); Access.Component "st_na"] |) ]] in
      do~ M.substitute_var "levels" [[ M.var_access (| "sm", [Access.Array (M.var (| "i" |)); Access.Component "st_upd"] |) ]] in
      do~ M.substitute_var "levels" [[ M.var_access (| "siblings", [Access.Array (M.var (| "i" |))] |) ]] in
      do~ M.substitute_var "levels" [[ M.var_access (| "hash1Old", [Access.Component "out"] |) ]] in
      do~ M.substitute_var "levels" [[ M.var_access (| "hash1New", [Access.Component "out"] |) ]] in
      do~ M.substitute_var "levels" [[ M.var_access (| "n2bNew", [Access.Component "out"; Access.Array (M.var (| "i" |))] |) ]] in
      do~ M.if_ [[ InfixOp.eq ~(| M.var (| "i" |), InfixOp.sub ~(| M.var (| "nLevels" |), 1 |) |) ]] (* then *) (
        do~ M.substitute_var "levels" [[ 0 ]] in
        do~ M.substitute_var "levels" [[ 0 ]] in
        M.pure BlockUnit.Tt
      ) (* else *) (
        do~ M.substitute_var "levels" [[ M.var_access (| "levels", [Access.Array (InfixOp.add ~(| M.var (| "i" |), 1 |)); Access.Component "oldRoot"] |) ]] in
        do~ M.substitute_var "levels" [[ M.var_access (| "levels", [Access.Array (InfixOp.add ~(| M.var (| "i" |), 1 |)); Access.Component "newRoot"] |) ]] in
        M.pure BlockUnit.Tt
      ) in
      do~ M.substitute_var "i" [[ InfixOp.sub ~(| M.var (| "i" |), 1 |) ]] in
      M.pure BlockUnit.Tt
    ) in
    (* Component *)
    do~ M.declare_component "topSwitcher" in
    do~ M.substitute_var "topSwitcher" [[ M.call_function ~(| "Switcher", ([] : list F.t) |) ]] in
    do~ M.substitute_var "topSwitcher" [[ InfixOp.mul ~(| M.var_access (| "fnc", [Access.Array (0)] |), M.var_access (| "fnc", [Access.Array (1)] |) |) ]] in
    do~ M.substitute_var "topSwitcher" [[ M.var_access (| "levels", [Access.Array (0); Access.Component "oldRoot"] |) ]] in
    do~ M.substitute_var "topSwitcher" [[ M.var_access (| "levels", [Access.Array (0); Access.Component "newRoot"] |) ]] in
    (* Component *)
    do~ M.declare_component "checkOldInput" in
    do~ M.substitute_var "checkOldInput" [[ M.call_function ~(| "ForceEqualIfEnabled", ([] : list F.t) |) ]] in
    do~ M.substitute_var "checkOldInput" [[ M.var (| "enabled" |) ]] in
    do~ M.substitute_var "checkOldInput" [[ M.var (| "oldRoot" |) ]] in
    do~ M.substitute_var "checkOldInput" [[ M.var_access (| "topSwitcher", [Access.Component "outL"] |) ]] in
    do~ M.substitute_var "newRoot" [[ InfixOp.add ~(| InfixOp.mul ~(| M.var (| "enabled" |), InfixOp.sub ~(| M.var_access (| "topSwitcher", [Access.Component "outR"] |), M.var (| "oldRoot" |) |) |), M.var (| "oldRoot" |) |) ]] in
    (* Component *)
    do~ M.declare_component "areKeyEquals" in
    do~ M.substitute_var "areKeyEquals" [[ M.call_function ~(| "IsEqual", ([] : list F.t) |) ]] in
    do~ M.substitute_var "areKeyEquals" [[ M.var (| "oldKey" |) ]] in
    do~ M.substitute_var "areKeyEquals" [[ M.var (| "newKey" |) ]] in
    (* Component *)
    do~ M.declare_component "keysOk" in
    do~ M.substitute_var "keysOk" [[ M.call_function ~(| "MultiAND", [ 3 ] |) ]] in
    do~ M.substitute_var "keysOk" [[ InfixOp.sub ~(| 1, M.var_access (| "fnc", [Access.Array (0)] |) |) ]] in
    do~ M.substitute_var "keysOk" [[ M.var_access (| "fnc", [Access.Array (1)] |) ]] in
    do~ M.substitute_var "keysOk" [[ InfixOp.sub ~(| 1, M.var_access (| "areKeyEquals", [Access.Component "out"] |) |) ]] in
    do~ M.equality_constraint
      [[ M.var_access (| "keysOk", [Access.Component "out"] |) ]]
      [[ 0 ]]
    in
    M.pure BlockUnit.Tt
  ).

(* Template not under-constrained *)
Definition SMTProcessor_not_under_constrained (nLevels : F.t) oldRoot siblings oldKey oldValue isOld0 newKey newValue fnc : Prop :=
  exists! newRoot,
  exists enabled,
  let signals := SMTProcessorSignals.Build_t oldRoot newRoot siblings oldKey oldValue isOld0 newKey newValue fnc enabled in
  True (* NotUnderConstrained SMTProcessor nLevels signals *).
