(* Generated by Garden *)
Require Import Garden.Garden.

(* Template signals *)
Module SMTProcessorSignals.
  Record t : Set := {
    (* Input *)
    oldRoot : F.t;
    (* Output *)
    newRoot : F.t;
    (* Input *)
    siblings : list F.t;
    (* Input *)
    oldKey : F.t;
    (* Input *)
    oldValue : F.t;
    (* Input *)
    isOld0 : F.t;
    (* Input *)
    newKey : F.t;
    (* Input *)
    newValue : F.t;
    (* Input *)
    fnc : list F.t;
    (* Intermediate *)
    enabled : F.t;
  }.

  Module IsNamed.
    Inductive P : forall (A : Set), (t -> A) -> string -> Prop :=
    | oldRoot : P _ oldRoot "oldRoot"
    | newRoot : P _ newRoot "newRoot"
    | siblings : P _ siblings "siblings"
    | oldKey : P _ oldKey "oldKey"
    | oldValue : P _ oldValue "oldValue"
    | isOld0 : P _ isOld0 "isOld0"
    | newKey : P _ newKey "newKey"
    | newValue : P _ newValue "newValue"
    | fnc : P _ fnc "fnc"
    | enabled : P _ enabled "enabled".
  End IsNamed.
End SMTProcessorSignals.

(* Template body *)
Definition SMTProcessor (nLevels : F.t) : M.t (BlockUnit.t Empty_set) :=
  M.template_body [("nLevels", nLevels)] (
    (* Signal Input *)
    do~ M.declare_signal "oldRoot" in
    (* Signal Output *)
    do~ M.declare_signal "newRoot" in
    (* Signal Input *)
    do~ M.declare_signal "siblings" in
    (* Signal Input *)
    do~ M.declare_signal "oldKey" in
    (* Signal Input *)
    do~ M.declare_signal "oldValue" in
    (* Signal Input *)
    do~ M.declare_signal "isOld0" in
    (* Signal Input *)
    do~ M.declare_signal "newKey" in
    (* Signal Input *)
    do~ M.declare_signal "newValue" in
    (* Signal Input *)
    do~ M.declare_signal "fnc" in
    (* Signal Intermediate *)
    do~ M.declare_signal "enabled" in
    (* Var *)
    do~ M.declare_var "i" [[ ([] : list F.t) ]] in
    do~ M.substitute_var "i" [] [[ 0 ]] in
    do~ M.substitute_var "enabled" [] [[ InfixOp.sub ~(| InfixOp.add ~(| M.var_access (| "fnc", [Access.Array (0)] |), M.var_access (| "fnc", [Access.Array (1)] |) |), InfixOp.mul ~(| M.var_access (| "fnc", [Access.Array (0)] |), M.var_access (| "fnc", [Access.Array (1)] |) |) |) ]] in
    (* Component *)
    do~ M.declare_component "hash1Old" in
    do~ M.substitute_var "hash1Old" [] [[ M.call_function ~(| "SMTHash1", ([] : list F.t) |) ]] in
    do~ M.substitute_var "hash1Old" [Access.Component "key"] [[ M.var (| "oldKey" |) ]] in
    do~ M.substitute_var "hash1Old" [Access.Component "value"] [[ M.var (| "oldValue" |) ]] in
    (* Component *)
    do~ M.declare_component "hash1New" in
    do~ M.substitute_var "hash1New" [] [[ M.call_function ~(| "SMTHash1", ([] : list F.t) |) ]] in
    do~ M.substitute_var "hash1New" [Access.Component "key"] [[ M.var (| "newKey" |) ]] in
    do~ M.substitute_var "hash1New" [Access.Component "value"] [[ M.var (| "newValue" |) ]] in
    (* Component *)
    do~ M.declare_component "n2bOld" in
    do~ M.substitute_var "n2bOld" [] [[ M.call_function ~(| "Num2Bits_strict", ([] : list F.t) |) ]] in
    (* Component *)
    do~ M.declare_component "n2bNew" in
    do~ M.substitute_var "n2bNew" [] [[ M.call_function ~(| "Num2Bits_strict", ([] : list F.t) |) ]] in
    do~ M.substitute_var "n2bOld" [Access.Component "in"] [[ M.var (| "oldKey" |) ]] in
    do~ M.substitute_var "n2bNew" [Access.Component "in"] [[ M.var (| "newKey" |) ]] in
    (* Component *)
    do~ M.declare_component "smtLevIns" in
    do~ M.substitute_var "smtLevIns" [] [[ M.call_function ~(| "SMTLevIns", [ M.var (| "nLevels" |) ] |) ]] in
    do~ M.substitute_var "i" [] [[ 0 ]] in
    do~ M.while [[ InfixOp.lesser ~(| M.var (| "i" |), M.var (| "nLevels" |) |) ]] (
      do~ M.substitute_var "smtLevIns" [Access.Component "siblings"; Access.Array (M.var (| "i" |))] [[ M.var_access (| "siblings", [Access.Array (M.var (| "i" |))] |) ]] in
      do~ M.substitute_var "i" [] [[ InfixOp.add ~(| M.var (| "i" |), 1 |) ]] in
      M.pure BlockUnit.Tt
    ) in
    do~ M.substitute_var "smtLevIns" [Access.Component "enabled"] [[ M.var (| "enabled" |) ]] in
    (* Component *)
    do~ M.declare_component "xors" in
    do~ M.substitute_var "i" [] [[ 0 ]] in
    do~ M.while [[ InfixOp.lesser ~(| M.var (| "i" |), M.var (| "nLevels" |) |) ]] (
      do~ M.substitute_var "xors" [Access.Array (M.var (| "i" |))] [[ M.call_function ~(| "XOR", ([] : list F.t) |) ]] in
      do~ M.substitute_var "xors" [Access.Array (M.var (| "i" |)); Access.Component "a"] [[ M.var_access (| "n2bOld", [Access.Component "out"; Access.Array (M.var (| "i" |))] |) ]] in
      do~ M.substitute_var "xors" [Access.Array (M.var (| "i" |)); Access.Component "b"] [[ M.var_access (| "n2bNew", [Access.Component "out"; Access.Array (M.var (| "i" |))] |) ]] in
      do~ M.substitute_var "i" [] [[ InfixOp.add ~(| M.var (| "i" |), 1 |) ]] in
      M.pure BlockUnit.Tt
    ) in
    (* Component *)
    do~ M.declare_component "sm" in
    do~ M.substitute_var "i" [] [[ 0 ]] in
    do~ M.while [[ InfixOp.lesser ~(| M.var (| "i" |), M.var (| "nLevels" |) |) ]] (
      do~ M.substitute_var "sm" [Access.Array (M.var (| "i" |))] [[ M.call_function ~(| "SMTProcessorSM", ([] : list F.t) |) ]] in
      do~ M.if_ [[ InfixOp.eq ~(| M.var (| "i" |), 0 |) ]] (* then *) (
        do~ M.substitute_var "sm" [Access.Array (M.var (| "i" |)); Access.Component "prev_top"] [[ M.var (| "enabled" |) ]] in
        do~ M.substitute_var "sm" [Access.Array (M.var (| "i" |)); Access.Component "prev_old0"] [[ 0 ]] in
        do~ M.substitute_var "sm" [Access.Array (M.var (| "i" |)); Access.Component "prev_bot"] [[ 0 ]] in
        do~ M.substitute_var "sm" [Access.Array (M.var (| "i" |)); Access.Component "prev_new1"] [[ 0 ]] in
        do~ M.substitute_var "sm" [Access.Array (M.var (| "i" |)); Access.Component "prev_na"] [[ InfixOp.sub ~(| 1, M.var (| "enabled" |) |) ]] in
        do~ M.substitute_var "sm" [Access.Array (M.var (| "i" |)); Access.Component "prev_upd"] [[ 0 ]] in
        M.pure BlockUnit.Tt
      ) (* else *) (
        do~ M.substitute_var "sm" [Access.Array (M.var (| "i" |)); Access.Component "prev_top"] [[ M.var_access (| "sm", [Access.Array (InfixOp.sub ~(| M.var (| "i" |), 1 |)); Access.Component "st_top"] |) ]] in
        do~ M.substitute_var "sm" [Access.Array (M.var (| "i" |)); Access.Component "prev_old0"] [[ M.var_access (| "sm", [Access.Array (InfixOp.sub ~(| M.var (| "i" |), 1 |)); Access.Component "st_old0"] |) ]] in
        do~ M.substitute_var "sm" [Access.Array (M.var (| "i" |)); Access.Component "prev_bot"] [[ M.var_access (| "sm", [Access.Array (InfixOp.sub ~(| M.var (| "i" |), 1 |)); Access.Component "st_bot"] |) ]] in
        do~ M.substitute_var "sm" [Access.Array (M.var (| "i" |)); Access.Component "prev_new1"] [[ M.var_access (| "sm", [Access.Array (InfixOp.sub ~(| M.var (| "i" |), 1 |)); Access.Component "st_new1"] |) ]] in
        do~ M.substitute_var "sm" [Access.Array (M.var (| "i" |)); Access.Component "prev_na"] [[ M.var_access (| "sm", [Access.Array (InfixOp.sub ~(| M.var (| "i" |), 1 |)); Access.Component "st_na"] |) ]] in
        do~ M.substitute_var "sm" [Access.Array (M.var (| "i" |)); Access.Component "prev_upd"] [[ M.var_access (| "sm", [Access.Array (InfixOp.sub ~(| M.var (| "i" |), 1 |)); Access.Component "st_upd"] |) ]] in
        M.pure BlockUnit.Tt
      ) in
      do~ M.substitute_var "sm" [Access.Array (M.var (| "i" |)); Access.Component "is0"] [[ M.var (| "isOld0" |) ]] in
      do~ M.substitute_var "sm" [Access.Array (M.var (| "i" |)); Access.Component "xor"] [[ M.var_access (| "xors", [Access.Array (M.var (| "i" |)); Access.Component "out"] |) ]] in
      do~ M.substitute_var "sm" [Access.Array (M.var (| "i" |)); Access.Component "fnc"; Access.Array (0)] [[ M.var_access (| "fnc", [Access.Array (0)] |) ]] in
      do~ M.substitute_var "sm" [Access.Array (M.var (| "i" |)); Access.Component "fnc"; Access.Array (1)] [[ M.var_access (| "fnc", [Access.Array (1)] |) ]] in
      do~ M.substitute_var "sm" [Access.Array (M.var (| "i" |)); Access.Component "levIns"] [[ M.var_access (| "smtLevIns", [Access.Component "levIns"; Access.Array (M.var (| "i" |))] |) ]] in
      do~ M.substitute_var "i" [] [[ InfixOp.add ~(| M.var (| "i" |), 1 |) ]] in
      M.pure BlockUnit.Tt
    ) in
    do~ M.equality_constraint
      [[ InfixOp.add ~(| InfixOp.add ~(| InfixOp.add ~(| M.var_access (| "sm", [Access.Array (InfixOp.sub ~(| M.var (| "nLevels" |), 1 |)); Access.Component "st_na"] |), M.var_access (| "sm", [Access.Array (InfixOp.sub ~(| M.var (| "nLevels" |), 1 |)); Access.Component "st_new1"] |) |), M.var_access (| "sm", [Access.Array (InfixOp.sub ~(| M.var (| "nLevels" |), 1 |)); Access.Component "st_old0"] |) |), M.var_access (| "sm", [Access.Array (InfixOp.sub ~(| M.var (| "nLevels" |), 1 |)); Access.Component "st_upd"] |) |) ]]
      [[ 1 ]]
    in
    (* Component *)
    do~ M.declare_component "levels" in
    do~ M.substitute_var "i" [] [[ InfixOp.sub ~(| M.var (| "nLevels" |), 1 |) ]] in
    do~ M.while [[ InfixOp.notEq ~(| M.var (| "i" |), PrefixOp.sub ~(| 1 |) |) ]] (
      do~ M.substitute_var "levels" [Access.Array (M.var (| "i" |))] [[ M.call_function ~(| "SMTProcessorLevel", ([] : list F.t) |) ]] in
      do~ M.substitute_var "levels" [Access.Array (M.var (| "i" |)); Access.Component "st_top"] [[ M.var_access (| "sm", [Access.Array (M.var (| "i" |)); Access.Component "st_top"] |) ]] in
      do~ M.substitute_var "levels" [Access.Array (M.var (| "i" |)); Access.Component "st_old0"] [[ M.var_access (| "sm", [Access.Array (M.var (| "i" |)); Access.Component "st_old0"] |) ]] in
      do~ M.substitute_var "levels" [Access.Array (M.var (| "i" |)); Access.Component "st_bot"] [[ M.var_access (| "sm", [Access.Array (M.var (| "i" |)); Access.Component "st_bot"] |) ]] in
      do~ M.substitute_var "levels" [Access.Array (M.var (| "i" |)); Access.Component "st_new1"] [[ M.var_access (| "sm", [Access.Array (M.var (| "i" |)); Access.Component "st_new1"] |) ]] in
      do~ M.substitute_var "levels" [Access.Array (M.var (| "i" |)); Access.Component "st_na"] [[ M.var_access (| "sm", [Access.Array (M.var (| "i" |)); Access.Component "st_na"] |) ]] in
      do~ M.substitute_var "levels" [Access.Array (M.var (| "i" |)); Access.Component "st_upd"] [[ M.var_access (| "sm", [Access.Array (M.var (| "i" |)); Access.Component "st_upd"] |) ]] in
      do~ M.substitute_var "levels" [Access.Array (M.var (| "i" |)); Access.Component "sibling"] [[ M.var_access (| "siblings", [Access.Array (M.var (| "i" |))] |) ]] in
      do~ M.substitute_var "levels" [Access.Array (M.var (| "i" |)); Access.Component "old1leaf"] [[ M.var_access (| "hash1Old", [Access.Component "out"] |) ]] in
      do~ M.substitute_var "levels" [Access.Array (M.var (| "i" |)); Access.Component "new1leaf"] [[ M.var_access (| "hash1New", [Access.Component "out"] |) ]] in
      do~ M.substitute_var "levels" [Access.Array (M.var (| "i" |)); Access.Component "newlrbit"] [[ M.var_access (| "n2bNew", [Access.Component "out"; Access.Array (M.var (| "i" |))] |) ]] in
      do~ M.if_ [[ InfixOp.eq ~(| M.var (| "i" |), InfixOp.sub ~(| M.var (| "nLevels" |), 1 |) |) ]] (* then *) (
        do~ M.substitute_var "levels" [Access.Array (M.var (| "i" |)); Access.Component "oldChild"] [[ 0 ]] in
        do~ M.substitute_var "levels" [Access.Array (M.var (| "i" |)); Access.Component "newChild"] [[ 0 ]] in
        M.pure BlockUnit.Tt
      ) (* else *) (
        do~ M.substitute_var "levels" [Access.Array (M.var (| "i" |)); Access.Component "oldChild"] [[ M.var_access (| "levels", [Access.Array (InfixOp.add ~(| M.var (| "i" |), 1 |)); Access.Component "oldRoot"] |) ]] in
        do~ M.substitute_var "levels" [Access.Array (M.var (| "i" |)); Access.Component "newChild"] [[ M.var_access (| "levels", [Access.Array (InfixOp.add ~(| M.var (| "i" |), 1 |)); Access.Component "newRoot"] |) ]] in
        M.pure BlockUnit.Tt
      ) in
      do~ M.substitute_var "i" [] [[ InfixOp.sub ~(| M.var (| "i" |), 1 |) ]] in
      M.pure BlockUnit.Tt
    ) in
    (* Component *)
    do~ M.declare_component "topSwitcher" in
    do~ M.substitute_var "topSwitcher" [] [[ M.call_function ~(| "Switcher", ([] : list F.t) |) ]] in
    do~ M.substitute_var "topSwitcher" [Access.Component "sel"] [[ InfixOp.mul ~(| M.var_access (| "fnc", [Access.Array (0)] |), M.var_access (| "fnc", [Access.Array (1)] |) |) ]] in
    do~ M.substitute_var "topSwitcher" [Access.Component "L"] [[ M.var_access (| "levels", [Access.Array (0); Access.Component "oldRoot"] |) ]] in
    do~ M.substitute_var "topSwitcher" [Access.Component "R"] [[ M.var_access (| "levels", [Access.Array (0); Access.Component "newRoot"] |) ]] in
    (* Component *)
    do~ M.declare_component "checkOldInput" in
    do~ M.substitute_var "checkOldInput" [] [[ M.call_function ~(| "ForceEqualIfEnabled", ([] : list F.t) |) ]] in
    do~ M.substitute_var "checkOldInput" [Access.Component "enabled"] [[ M.var (| "enabled" |) ]] in
    do~ M.substitute_var "checkOldInput" [Access.Component "in"; Access.Array (0)] [[ M.var (| "oldRoot" |) ]] in
    do~ M.substitute_var "checkOldInput" [Access.Component "in"; Access.Array (1)] [[ M.var_access (| "topSwitcher", [Access.Component "outL"] |) ]] in
    do~ M.substitute_var "newRoot" [] [[ InfixOp.add ~(| InfixOp.mul ~(| M.var (| "enabled" |), InfixOp.sub ~(| M.var_access (| "topSwitcher", [Access.Component "outR"] |), M.var (| "oldRoot" |) |) |), M.var (| "oldRoot" |) |) ]] in
    (* Component *)
    do~ M.declare_component "areKeyEquals" in
    do~ M.substitute_var "areKeyEquals" [] [[ M.call_function ~(| "IsEqual", ([] : list F.t) |) ]] in
    do~ M.substitute_var "areKeyEquals" [Access.Component "in"; Access.Array (0)] [[ M.var (| "oldKey" |) ]] in
    do~ M.substitute_var "areKeyEquals" [Access.Component "in"; Access.Array (1)] [[ M.var (| "newKey" |) ]] in
    (* Component *)
    do~ M.declare_component "keysOk" in
    do~ M.substitute_var "keysOk" [] [[ M.call_function ~(| "MultiAND", [ 3 ] |) ]] in
    do~ M.substitute_var "keysOk" [Access.Component "in"; Access.Array (0)] [[ InfixOp.sub ~(| 1, M.var_access (| "fnc", [Access.Array (0)] |) |) ]] in
    do~ M.substitute_var "keysOk" [Access.Component "in"; Access.Array (1)] [[ M.var_access (| "fnc", [Access.Array (1)] |) ]] in
    do~ M.substitute_var "keysOk" [Access.Component "in"; Access.Array (2)] [[ InfixOp.sub ~(| 1, M.var_access (| "areKeyEquals", [Access.Component "out"] |) |) ]] in
    do~ M.equality_constraint
      [[ M.var_access (| "keysOk", [Access.Component "out"] |) ]]
      [[ 0 ]]
    in
    M.pure BlockUnit.Tt
  ).

(* Template not under-constrained *)
Definition SMTProcessor_not_under_constrained (nLevels : F.t) oldRoot siblings oldKey oldValue isOld0 newKey newValue fnc : Prop :=
  exists! newRoot,
  exists enabled,
  let signals := SMTProcessorSignals.Build_t oldRoot newRoot siblings oldKey oldValue isOld0 newKey newValue fnc enabled in
  True (* NotUnderConstrained SMTProcessor nLevels signals *).
