(* Generated by Garden *)
Require Import Circom.M.

(* Template signals *)
Module SMTProcessorSMSignals.
  Record t : Set := {
    (* Input *)
    xor : F.t;
    (* Input *)
    is0 : F.t;
    (* Input *)
    levIns : F.t;
    (* Input *)
    fnc : list F.t;
    (* Input *)
    prev_top : F.t;
    (* Input *)
    prev_old0 : F.t;
    (* Input *)
    prev_bot : F.t;
    (* Input *)
    prev_new1 : F.t;
    (* Input *)
    prev_na : F.t;
    (* Input *)
    prev_upd : F.t;
    (* Output *)
    st_top : F.t;
    (* Output *)
    st_old0 : F.t;
    (* Output *)
    st_bot : F.t;
    (* Output *)
    st_new1 : F.t;
    (* Output *)
    st_na : F.t;
    (* Output *)
    st_upd : F.t;
    (* Intermediate *)
    aux1 : F.t;
    (* Intermediate *)
    aux2 : F.t;
  }.

  Module IsNamed.
    Inductive P : forall (A : Set), (t -> A) -> string -> Prop :=
    | xor : P _ xor "xor"
    | is0 : P _ is0 "is0"
    | levIns : P _ levIns "levIns"
    | fnc : P _ fnc "fnc"
    | prev_top : P _ prev_top "prev_top"
    | prev_old0 : P _ prev_old0 "prev_old0"
    | prev_bot : P _ prev_bot "prev_bot"
    | prev_new1 : P _ prev_new1 "prev_new1"
    | prev_na : P _ prev_na "prev_na"
    | prev_upd : P _ prev_upd "prev_upd"
    | st_top : P _ st_top "st_top"
    | st_old0 : P _ st_old0 "st_old0"
    | st_bot : P _ st_bot "st_bot"
    | st_new1 : P _ st_new1 "st_new1"
    | st_na : P _ st_na "st_na"
    | st_upd : P _ st_upd "st_upd"
    | aux1 : P _ aux1 "aux1"
    | aux2 : P _ aux2 "aux2".
  End IsNamed.
End SMTProcessorSMSignals.

(* Template body *)
Definition SMTProcessorSM : M.t (BlockUnit.t Empty_set) :=
  M.template_body [] (
    (* Signal Input *)
    do~ M.declare_signal "xor" in
    (* Signal Input *)
    do~ M.declare_signal "is0" in
    (* Signal Input *)
    do~ M.declare_signal "levIns" in
    (* Signal Input *)
    do~ M.declare_signal "fnc" in
    (* Signal Input *)
    do~ M.declare_signal "prev_top" in
    (* Signal Input *)
    do~ M.declare_signal "prev_old0" in
    (* Signal Input *)
    do~ M.declare_signal "prev_bot" in
    (* Signal Input *)
    do~ M.declare_signal "prev_new1" in
    (* Signal Input *)
    do~ M.declare_signal "prev_na" in
    (* Signal Input *)
    do~ M.declare_signal "prev_upd" in
    (* Signal Output *)
    do~ M.declare_signal "st_top" in
    (* Signal Output *)
    do~ M.declare_signal "st_old0" in
    (* Signal Output *)
    do~ M.declare_signal "st_bot" in
    (* Signal Output *)
    do~ M.declare_signal "st_new1" in
    (* Signal Output *)
    do~ M.declare_signal "st_na" in
    (* Signal Output *)
    do~ M.declare_signal "st_upd" in
    (* Signal Intermediate *)
    do~ M.declare_signal "aux1" in
    (* Signal Intermediate *)
    do~ M.declare_signal "aux2" in
    do~ M.substitute_var "aux1" [] [[ InfixOp.mul ~(| M.var (| "prev_top" |), M.var (| "levIns" |) |) ]] in
    do~ M.substitute_var "aux2" [] [[ InfixOp.mul ~(| M.var (| "aux1" |), M.var_access (| "fnc", [Access.Array (0)] |) |) ]] in
    do~ M.substitute_var "st_top" [] [[ InfixOp.sub ~(| M.var (| "prev_top" |), M.var (| "aux1" |) |) ]] in
    do~ M.substitute_var "st_old0" [] [[ InfixOp.mul ~(| M.var (| "aux2" |), M.var (| "is0" |) |) ]] in
    do~ M.substitute_var "st_new1" [] [[ InfixOp.mul ~(| InfixOp.add ~(| InfixOp.sub ~(| M.var (| "aux2" |), M.var (| "st_old0" |) |), M.var (| "prev_bot" |) |), M.var (| "xor" |) |) ]] in
    do~ M.substitute_var "st_bot" [] [[ InfixOp.mul ~(| InfixOp.sub ~(| 1, M.var (| "xor" |) |), InfixOp.add ~(| InfixOp.sub ~(| M.var (| "aux2" |), M.var (| "st_old0" |) |), M.var (| "prev_bot" |) |) |) ]] in
    do~ M.substitute_var "st_upd" [] [[ InfixOp.sub ~(| M.var (| "aux1" |), M.var (| "aux2" |) |) ]] in
    do~ M.substitute_var "st_na" [] [[ InfixOp.add ~(| InfixOp.add ~(| InfixOp.add ~(| M.var (| "prev_new1" |), M.var (| "prev_old0" |) |), M.var (| "prev_na" |) |), M.var (| "prev_upd" |) |) ]] in
    M.pure BlockUnit.Tt
  ).

(* Template not under-constrained *)
Definition SMTProcessorSM_not_under_constrained xor is0 levIns fnc prev_top prev_old0 prev_bot prev_new1 prev_na prev_upd : Prop :=
  exists! st_top st_old0 st_bot st_new1 st_na st_upd,
  exists aux1 aux2,
  let signals := SMTProcessorSMSignals.Build_t xor is0 levIns fnc prev_top prev_old0 prev_bot prev_new1 prev_na prev_upd st_top st_old0 st_bot st_new1 st_na st_upd aux1 aux2 in
  True (* NotUnderConstrained SMTProcessorSM signals *).
