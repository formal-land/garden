
(* Generated by Garden *)
Require Import Garden.Garden.

(* Function *)
Definition nbits (a : F.t) : M.t F.t :=
  M.function_body (
    (* Var *)
    do~ M.declare_var "n" [[ [] ]] in
    do~ M.substitute "n" [[ 1 ]] in
    (* Var *)
    do~ M.declare_var "r" [[ [] ]] in
    do~ M.substitute "r" [[ 0 ]] in
    do~ M.while [[ InfixOp.Lesser ~(| InfixOp.Sub ~(| M.var ~(| "n" |), 1 |), M.var ~(| "a" |) |)]]
      do~ M.substitute "r" [[ InfixOp.Add ~(| M.var ~(| "r" |), 1 |) ]] in
      do~ M.substitute "n" [[ InfixOp.Mul ~(| M.var ~(| "n" |), 1 |) ]] in
      M.pure tt
    in
    do~ M.return [[ M.var ~(| "r" |) ]] in
    M.pure tt
  ).

(* Template *)
Definition BinSum (n ops : F.t) : Template.t F.t :=
  (* Var *)
  do~ M.declare_var "nout" [[ [] ]] in
  do~ M.substitute "nout" [[ nbits ~(| InfixOp.Mul ~(| InfixOp.Sub ~(| InfixOp.Pow ~(| 1, M.var ~(| "n" |) |), 1 |), M.var ~(| "ops" |) |) |) ]] in
  (* Signal Input *)
  do~ M.declare_signal "in" [[ [M.var ~(| "ops" |); M.var ~(| "n" |)] ]] in
  (* Signal Output *)
  do~ M.declare_signal "out" [[ [M.var ~(| "nout" |)] ]] in
  (* Var *)
  do~ M.declare_var "lin" [[ [] ]] in
  do~ M.substitute "lin" [[ 0 ]] in
  (* Var *)
  do~ M.declare_var "lout" [[ [] ]] in
  do~ M.substitute "lout" [[ 0 ]] in
  (* Var *)
  do~ M.declare_var "k" [[ [] ]] in
  do~ M.substitute "k" [[ 0 ]] in
  (* Var *)
  do~ M.declare_var "j" [[ [] ]] in
  do~ M.substitute "j" [[ 0 ]] in
  (* Var *)
  do~ M.declare_var "e2" [[ [] ]] in
  do~ M.substitute "e2" [[ 0 ]] in
  do~ M.substitute "e2" [[ 1 ]] in
  do~ M.substitute "k" [[ 0 ]] in
  do~ M.while [[ InfixOp.Lesser ~(| M.var ~(| "k" |), M.var ~(| "n" |) |)]]
    do~ M.substitute "j" [[ 0 ]] in
    do~ M.while [[ InfixOp.Lesser ~(| M.var ~(| "j" |), M.var ~(| "ops" |) |)]]
      do~ M.substitute "lin" [[ InfixOp.Add ~(| M.var ~(| "lin" |), InfixOp.Mul ~(| M.var_access ~(| "in", [Access.Array M.var ~(| "j" |); Access.Array M.var ~(| "k" |)] |), M.var ~(| "e2" |) |) |) ]] in
      M.pure tt
      do~ M.substitute "j" [[ InfixOp.Add ~(| M.var ~(| "j" |), 1 |) ]] in
      M.pure tt
    in
    M.pure tt
    do~ M.substitute "e2" [[ InfixOp.Add ~(| M.var ~(| "e2" |), M.var ~(| "e2" |) |) ]] in
    M.pure tt
    do~ M.substitute "k" [[ InfixOp.Add ~(| M.var ~(| "k" |), 1 |) ]] in
    M.pure tt
  in
  M.pure tt
  do~ M.substitute "e2" [[ 1 ]] in
  do~ M.substitute "k" [[ 0 ]] in
  do~ M.while [[ InfixOp.Lesser ~(| M.var ~(| "k" |), M.var ~(| "nout" |) |)]]
    do~ M.substitute "out" [[ InfixOp.BitAnd ~(| InfixOp.ShiftR ~(| M.var ~(| "lin" |), M.var ~(| "k" |) |), 1 |) ]] in
    do~ M.equality_constraint
      [[ InfixOp.Mul ~(| M.var_access ~(| "out", [Access.Array M.var ~(| "k" |)] |), InfixOp.Sub ~(| M.var_access ~(| "out", [Access.Array M.var ~(| "k" |)] |), 1 |) |) ]]
      [[ 0 ]]
    in
    do~ M.substitute "lout" [[ InfixOp.Add ~(| M.var ~(| "lout" |), InfixOp.Mul ~(| M.var_access ~(| "out", [Access.Array M.var ~(| "k" |)] |), M.var ~(| "e2" |) |) |) ]] in
    do~ M.substitute "e2" [[ InfixOp.Add ~(| M.var ~(| "e2" |), M.var ~(| "e2" |) |) ]] in
    M.pure tt
    do~ M.substitute "k" [[ InfixOp.Add ~(| M.var ~(| "k" |), 1 |) ]] in
    M.pure tt
  in
  M.pure tt
  do~ M.equality_constraint
    [[ M.var ~(| "lin" |) ]]
    [[ M.var ~(| "lout" |) ]]
  in
  M.pure tt.
